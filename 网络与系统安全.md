## 第一章 新形势安全面临挑战和安全保障能力提升

信息技术的发展趋势：融合、扩张、协作；

信息安全面临的挑战：隐私、身份、电子依赖、信任绑架、信息财富、边界模糊

信息安全的技术发展趋势，保护、检测、可生存、可信赖；

------

## 第二章 网络与系统安全的需求与目标

网络与系统安全的目标：

- 机密性Confidentiality：受保护的数据不受非法截获和未经授权浏览
- 完整性Integrity：能够保障被传输、接收或存储的数据是完整的和未被篡改的
- 可用性Available：面对外界突然情况（或攻击）数据或服务仍然可用
- 真实性Authenticated：提供信息服务及其安全保护真实性证明

信息安全的目标：控制风险。信息安全风险：威胁（Threats）利用弱点（Vulnerabilities）给信息资产（Assets）造成负面影响（Impacts）的潜在可能（Likelihood）

保护阶段的目标：TCSEC 橘皮书和 CC 标准。DOS时代随意修改中断向量表，后来系统开始分级ring0-3

生命周期阶段：入侵检测技术：监视、评估信息网络系统中的恶意或者违反安全策略的行为，并产生相应的报警；PDCA：Plan-Do-Check-Act

可生存技术：错误容忍：拜占庭容错和门限密码技术

自重构可信赖保护技术：动态构建、适度安全、随着任务启动生成保护，随任务结束退出

------

## 第三章 系统自主与强制访问控制

OSI五层安全体系结构：鉴别，访问控制，机密性，完整性，非否认

访问控制：主体subject只能对客体object根据控制策略进行授权的操作。访问包括读r、写w、执行x（使用资源完成特定功能）

审计：监测访问控制机制的运行状态，一般只记录对文件的首次和末次访问

### 访问控制基本类型

- 自主访问控制DAC（Discretionary Access Control）：基于身份的访问控制。用户以个体或用户组的身份访问。自主指的是客体的属主可以自己决定是否将自己的客体访问权授予其他主体。例如：UGO、ACL访问控制、capability机制
- 强制访问控制MAC（Mandatory Access Control）：也称为基于规则的访问控制。用户和客体有多级，只有管理员能确定用户和组的访问权限（而不是主体来决定），完全根据主体和客体的安全级别决定访问。例如：基于属性的访问控制ABAC、SELinux
- 基于角色的访问控制RBAC（Role based Access Control）：用户属于角色，不同角色有自己的操作集，由管理员分配操作集给角色
  组和角色的区别：角色=组+一组操作权限

访问控制策略实施

- 访问控制矩阵：行为主体，列为客体，元素是操作。缺点：太大，稀疏
- 访问控制列表：每个客体维护一个列表，存用户的操作，相当于访问控制矩阵的一列。适用于要区分的用户相对少。例如Linux的UGO和ACL机制
- 访问控制能力：用户的能力相当于ticket，无需知道用户身份

### 自主访问控制DAC

#### UGO自主访问控制

每个文件上附加二进制位，反映文件拥有者user, group, other用户的访问控制。一共9bit

| user | group | other |
| ---- | ----- | ----- |
| rwx  | rwx   | rwx   |

输入`ls -l file.txt`即可看到文件的访问控制列表。

```
-rwxrwxrwx 1 mika mika       51 Jan  1  2022  package.json
```

`-rw-rw-r--`最前面的-代表文件是普通类型

- 第一组的rw-代表**文件属主**有读写权限
- 第二组的rw-代表**同组其他用户**有读写权限
- 第三组的r--代表其他用户只有读权限。

主体使用`chmod 777 file_name`来授权，代表三项都是111，即`-rwxrwxrwx`任意访问

UGO访问控制依赖信息

- /etc/group：组信息。`组名:密码:组内用户列表`。例如`adm:x:4:syslog,mika`

- /etc/passwd：用户信息。`用户名:密码:UID（用户ID）:GID（组ID）:描述性信息:主目录:默认Shell`。例如`root:x:0:0:root:/root:/bin/bash`

- /etc/shadow：存储用户密码的hash值

sudo：赋予普通用户特殊权限，输的是用户的口令，不是root的



#### ACL自主访问控制

ext4文件系统中，磁盘有一块inode表存储inode，包含每个用户对每个文件的权限，更细粒度

表之后的空间有文件的扩展属性xattr，包含ACL控制规则。进程读写执行文件时，检查进程所属用户主体在该文件ACL控制规则中是否具有该操作的权限

#### Capability机制

为了防止root用户权限过大，将root权限划分为38种能力，规定进程是否拥有某种能力

### 自主访问控制的不足

如果一个用户被授权访问，那么该用户的所有程序都将可以访问授权的资源。不能识别自然人与计算机程序之间最基本的区别

安卓的沙箱sandbox机制：在UGO的基础上，每个app作为系统用户有一个uid，只能访问自己的文件和共享文件，隔离了不同app之间的交互

### 多级强制访问控制

特权环：ring0内核

BLP模型：主体和客体都有等级，主体的等级越高，可访问的信息越敏感；客体的等级越高，机密性越高。主体只不能读安全级别高于它的客体，主体不能写安全级别低于它的客体。BLP仅关注信息的机密性，保证机密信息不会从高安全级别流向低安全级别

BIBA模型：主体只能读安全级别高于它的客体（如内核态页表），主体只能写、调用安全级别低于它的客体。BLP关注信息的完整性，和BLP完全相反



Clark-Wilson模型：TP系统的有效状态，需要从一个TP转为另一个TP

------

## 第四章 网络通道与边界防护

企业网络：企业内跨部门的交互通信，需要多个网之间通过通道连接

主动攻击：涉及到改变数据包的攻击，以影响系统正常工作。如DoS，IP、ARP欺骗、重放攻击
被动攻击：窃听数据，不影响系统工作。如嗅探，键盘记录，信道窃听

网络通道防护：保证网络通信的数据流是完整、机密、来源真实的，主要通过安全协议
网络边界防护：防止外界对企业网络的攻击，主要通过防火墙

### 网络通道防护技术——VPN

网络安全协议

- 网络层：IPSec，IPSec VPN
- 传输层：SSL/TLS，SSL VPN
- 应用层：PGP，S/MIME，DNSSEC

#### IPSec

IPSec的功能：

- 访问控制：阻止非授权的资源访问
- 无连接完整性：保证收到的数据没有被篡改
- 机密性：保证真正的接收方才能获取真正的发送内容
- 鉴别：数据来源可靠
- 重放保护：保证双方每次交换的数据都是不同的

IPSec体系结构：

- 协议部分：
  - AH（认证头）协议：利用哈希产生的校验值保证完整性，加入共享密钥鉴别数据源身份，AH报头的序列号防止重放攻击
  - ESP（封装安全载荷）：加密IP包载荷部分或整个包，分别对应IPSec的两种运行模式：传输模式（主机之间）和隧道模式（网关之间）
  - SA（安全关联）：协商了两个IPSec实体之间使用什么协议、运行模式、加密算法等
- 密钥管理：IKE（Internet密钥交换协议）自动协商密钥

IPSec每个分支之间两两可以访问，而VPN隧道是多对一的

```
作业
1.如何用IPSec协议实现小区宽带的收费？
小区每户的设备属于一个子网，每个子网的路由器都会连接到宽带公司的路由器上，宽带公司需要对于每个子网发来的数据包进行身份认证，从而根据用户是否缴费来让防火墙放行用户对于互联网的访问。首先，用户会使用客户端软件向宽带公司提交上网请求，客户端发出的IP数据报即使用IPsec协议。IPsec使用IKE（因特网密钥交换）来实现身份鉴别和密钥交换，一般采用预共享字符串或数字证书的方法实现认证，这里可以在办宽带时商定好预共享字符串。一旦身份认证和密钥交换完成，即可使用ESP协议和交换得到的加密密钥来对宽带上的流量进行加密，并通过哈希密钥对数据计算摘要，保证数据的完整性。如果用户已经交过费，那么宽带公司即可允许用户采用IPsec VPN的隧道模式访问互联网，即在整个数据包的首尾添加ESP头和ESP尾，然后再添加新的IP头，来通过防火墙。
2.在网络哪个层面部署安全通信协议最为安全？
我认为在网络层部署安全通信协议最安全。网络层主要有两个功能：路由选择和分组转发。在分组转发时，网络层的IPsec协议对于TCP和UDP报文都可以进行加密，而上层的SSL/TLS协议则只支持TCP应用程序。在路由选择时，IPsec可以通过安全关联SA来决定两个实体之间的安全策略，通过这种预先配置的方法来保证对不同的数据包采用不同的保护方法。
```

#### VPN

VPN是使用隧道技术在公网上虚拟出一条点到点的专线技术，隧道协议通常有数据链路层（L2F），网络层（IPsec），传输层（SSL）

VPN因为加密了（包括ip地址），所以防火墙无法解密进而拦截

IPSec VPN：需要安装客户端软件，组网不灵活，一旦组网变化需要调整原有IPsec配置

SSL VPN：在传输层和应用层之间，不会改变IP头和TCP头，不会影响原有网络拓扑

#### SSL/TLS

SSL可以实现客户对服务器的身份鉴别，通过浏览器使用数字证书；服务器对客户的鉴别，使用证书或者口令；建立服务器与客户之间安全的数据通道

TLS是SSL的进一步标准化。应用程序只要采用SSL 套接字API替代标准的socket，就可以把程序转为安全的，保证数据机密性和完整性。如HTTP+SSL->HTTPS

SSL握手：客户和服务器协商密码算法，必须鉴别服务器，可选鉴别客户端
record层：使用密码运算参数

- client hello：时间+随机数
- server hello：
- master secret

PGP（Pretty Good Privacy）

### 网络边界防护技术——防火墙

防火墙：实施网间访问控制的一组组件的集合，包括硬件+软件+控制策略

（1）包过滤防火墙：工作在网络层，根据源/目的socket制定过滤规则，通常在路由器上。

当一个数据包到来时，防火墙拆开包，查看TCP/IP报头（不处理数据），从上到下匹配规则表，只要匹配到一条规则，就决定如何处理；如果规则都不匹配，则根据缺省策略处理。

两种缺省策略：一切未被允许的就是禁止的（推荐）；一切未被允许的就是禁止的

例：防火墙规则

| 组序号 | 动作 | 源IP     | 目的IP   | 源端口 | 目的端口 | 协议类型 |
| ------ | ---- | -------- | -------- | ------ | -------- | -------- |
| 1      | 允许 | 10.1.1.1 | *        | *      | *        | TCP      |
| 2      | 允许 | *        | 10.1.1.1 | 20     | *        | TCP      |
| 3      | 禁止 | *        | 10.1.1.1 | 20     | <1024    | TCP      |

第一条规则：内部主机10.1.1.1任何端口访问任何主机的任何端口，基于TCP协议的数据包都允许通过
第二条规则：任何主机的20端口访问主机10.1.1.1的任何端口，基于TCP协议的数据包允许通过
第三条规则：任何主机的20端口访问主机10.1.1.1小于1024的端口，如果基于TCP协议的数据包都禁止通过

碎片攻击：将数据包分成多段骗过防火墙，进入内网再拼装

（2）应用层网关防火墙：拆开数据包（不仅需要包头还需要数据部分），解析应用的命令，过滤掉命令

（3）状态检测防火墙：建立连接状态表记住TCP连接状态，过滤没建立连接的

（4）代理服务器型防火墙：使得外部计算机的网络链路只能到达代理服务器，内部网络只接受代理提出的服务请求，隔离防火墙内外计算机系统

------

## 第五章 网络权限管理

传统利用数字签名进行身份鉴别

- server向client发送随机数S
- client产生随机数A，签名sign(A||S)，以及A发给server
- server可以用client的公钥鉴别client

### PKI体系结构

PKI公钥基础设施：绑定公钥和身份。基本组件：CA，证书订户，依赖方（使用证书来鉴别）。基本操作：证书的申请、签发、获取、验证、撤销

证书/数字证书/公钥证书PKC：CA的私钥对订户公钥的加密

证书的安全需求：数据源鉴别，数据完整性，非否认

证书包括三大部分

- 证书内容：主体，公钥，签发者，有效期，辅助信息
- CA的签名算法
- CA对证书内容的签名结果

如何验证证书的有效性：用CA的公钥来解密CA对证书内容的签名结果，与证书内容相比较，如果相同则证明证书是有效的

证书使用ASN.1语法，DER编码

证书链：先验证根CA的自签名证书（证书里面是子CA的公钥），再验证子CA的证书（证书里面是下一层子CA的公钥）...最后得到订户公钥，验证订户身份

证书注册机构RA：专门用于验证申请证书的人的身份，再让CA签发证书

证书撤销列表CRL：由CA签名，包含被撤销证书的序列号，定期更新非实时
在线证书状态协议OCSP：请求证书状态？响应是否撤销

公钥证书扩展：在证书中带有更多信息，如密钥用途、证书策略CP（用于区分不同证书安全等级，用于不同安全服务）、订户的属性信息（如果证书颁发者和权限授予者相同，则证书可以用于权限管理）。X.509证书带有民族、生日等订户信息

网上银行应用：用户用自己的私钥加密交易信息发给银行

### PMI体系及属性证书

X.509数字证书的扩展有订户的属性，如果写入权限信息，就可以让服务器得知订户的权限。但是订户权限会经常变化；订户在申请证书时就提供自己的权限，但一般证书颁发者和权限授予者不同，CA需要经常与应用系统通信进行确认，增加了CA的复杂性；另外同一个订户在不同应用系统中的角色权限往往不同。所以引入PMI进行权限管理和传递

权限管理基础设施PMI（Privilege Management Infrastructure）：专用于权限管理的基础设施。两个过程：认证、授权管理

PMI的组件：

- 属性中心AA（Attribute Authority）：颁发属性证书AC（Attribute Certificate），属性证书绑定实体身份信息和权限。
- 根属性中心SOA（Source of Authority）：最上级的AA，负责向其他实体下发权限
- 权限声称者：应用系统的访问者，需要向应用系统声明自己的权限
- 权限验证者：验证访问者权限的应用系统

PMI建立在PKI基础上：为了验证AC，需要AA的公钥，也就需要验证AA的公钥证书，这就需要PKI。除此之外应用系统的每个访问者都需要有属性证书和公钥证书，这样才能进行身份和权限的双重认证。

PERMIS PMI

------

## 第六章 基于属性的访问控制ABAC

### SELinux和类型强制访问控制

SELinux是美国国家安全局对强制访问控制的一种实现，是一种安全Linux子系统。SElinux使用**类型强制访问控制**（TE），是一种强制访问控制，访问控制都是写好的不能改。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）

SELinux中，每个进程和文件都有访问控制属性，称为**安全上下文**，格式为【用户user：角色role：类型type：类别】。类型都以_t结尾

```sh
# ls -Z /etc/shadow 文件的role只能是object_r
-r---- root root system_u:object_r:shadow_t shadow
```

因为是基于类型的强制访问控制，所以只需关注主体和客体的类型。TE**默认不允许任何访问**，除非通过使用allow规则（TE策略规则）对主客体类型授予访问权限。例如`allow user_t bin_t: file {read execute}`：域类型为user_t的进程可以读、执行bin_t类型的文件。allow规则四部分：

- 源类型/域类型（域）：主体进程的类型
- 目标类型：客体的类型
- 客体类别：允许访问的客体种类名称，如文件、目录
- 许可：访问种类

例如：SELinux只允许passwd进程来修改/etc/shadow密码文件，而无论运行程序的用户是谁。所以不能通过allow规则让非受信的user_t类型来直接访问shadow文件

```shell
# 允许域为passwd_t的进程来修改/etc/shadow密码文件
allow passwd_t shadow_t: file {ioctl read write create getattr setattr lock relabelfrom relabelto append unlink link rename}
```



域类型转变：selinux下的跨域指的是进程A想要访问文件B，但A的上下文并没有权限访问文件B，selinux支持我们开放进程A的权限，使其可以通过具有权限访问文件B的上下文的进程C，来间接实现对B的访问。当A_t试图访问B_t时总是默认转换为C_t

```
allow A_t B_t: file {getattr execute};
allow C_t B_t: file entrypoint;
allow A_t C_t: process transition;
```

[[学习记录\]通过selinux实现跨域 - 走看看 (zoukankan.com)](http://t.zoukankan.com/trickofjoker-p-12060122.html)

例如：用户创建了一个shell进程，类型为user_t。现在需要将域为user_t的shell进程转变为域为passwd_t的进程，才能访问shadow文件

```sh
# 允许域为user_t的shell进程对passwd可执行文件passwd_exec_t类型的进程使用execute()系统调用，即允许shell进程调用execute()执行passwd进程
allow user_t passwd_exec_t : file{getattr execute}
# 提供passwd_t域的入口访问权，即passwd_exec_t类型的进程可以使用passwd_t域
allow passwd_t passwd_exec_t : file entrypoint
# 允许user_t域转变为passwd_t域
allow user_t passwd_t: process transition
```

注：这里passwd是一个进程，它有两个域，passwd_exec_t和passwd_t。其中passwd_t类型的进程可以访问shadow，所以先让user_t（进程当前域）有能力执行passwd_exec_t，再让passwd_exec_t有能力进入passwd_t域（进程），最后让user_t转为passwd_t

[【SELinux学习笔记】概念_高桐@BILL的博客-CSDN博客](https://blog.csdn.net/huangyabin001/article/details/47404495)

### 基于属性的访问控制ABAC

基于属性的访问控制：主体访问客体基于【主客体属性、访问发生时的条件、由（属性，条件）信息组成的规则】

ABAC相比传统的访问控制

- 更细粒度
- 更灵活：身份和角色相对固定，而属性和规则可以修改

对于非ABAC来说，如果A组织的主体访问B组织的客体，需要在B组织创建A的账户并进行授权。每个组织都要维护一个授权列表

ABAC架构：ACM（访问控制机构）收到主体的访问控制请求，根据规则检查主客体属性、条件，决定是否允许操作

基于身份、角色的访问控制是ABAC的特例

企业级访问控制：一些存在信息共享需求的实体联盟，实体信息的共享需要进行管控

---

## 第七章 安卓系统权限管理

传统PC应用根据用户UID进行访问控制，每个用户被分配shell进程，一个用户所有进程的UID相同

移动终端每个应用APP是一个用户，有自己的权限，进程间通信频繁。每个APP有一个UID

### Android系统架构

安卓启动过程：

- 处理器SOC（系统级芯片）上电，启动ARM ROM代码
- ARM ROM从指定位置读取Uboot镜像
- Uboot将Linux内核镜像文件读入内存
- 启动Linux内核
- 启动init进程。在init.rc脚本中确定要启动的进程，如zygote进程（所有进程的父进程）

Zygote用socket通信，有一个listen端口，接收ActivityManangerService的请求，fork应用程序。App使用system server来请求zygote，zygote来fork一个进程给app用

Binder机制：一种进程间通信机制。不同app调用libbinder.so库发送parcer包进行进程间通信

System Server进程：提供了Android系统的大部分服务，其中包括Activity Mananger Service等

Sandbox机制：隔离不同app的私有数据访问，每个APP只能访问自己package安装文件下的data子文件夹中的数据。

Android APP 安装：

- APK文件包含配置信息文件mainfest.xml、程序的执行代码、资源文件、so库文件
- 代码签名机制：允许用户（开发者）使用自签名的证书对应用程序进行签名，保证应用来源。拥有相同代码签名的APP可以共享一个UID，从而可以共享文件

### Android Permission机制

Android Permission机制：是代码签名机制后，对APP权限的进一步访问控制，是一种强制访问控制

开发者在apk的配置文件mainfest.xml里声明了APP需要的授权信息，安装后权限信息会保存到系统的package.xml文件

当APP访问系统资源时，系统先检查APP的权限信息，APP使用System Server等进程提供的API来访问系统资源

### Android Permission机制安全性讨论

- 权限过度申请：APP申请过多的权限
- 权限合谋攻击：某些APP可以共享信息（如有相同签名的APP），为躲避恶意代码检查，每个APP拥有少量权限，但是它们合起来可以有充分的权限
- 权限提升：获取系统root权限、直接攻击Packages.xml

------

## 第八章 入侵检测系统IDS

PDRR模型：保护、检测、响应、恢复

入侵监测系统（IDS，Intrusion Detection System）：一种监视网络或系统活动，对恶意活动或违反策略的行为上报给管理站的设备或者软件应用



### 误用入侵检测

误用入侵检测系统（MISUSE）：认为攻击行为有明晰的、可分辨的特征。对特定入侵行为模式编码，无须训练，只能检测已知攻击

Snort系统：基于快速模式匹配，可以在其上编写Snort规则，写入配置文件。检查各种报头，字节匹配。使用libpacap库来捕获数据包

Bro系统：基于连接而非单数据包

专家系统：使用if-then的规则格式

状态转移分析STA：系统状态表示为系统属性或用户权限，由用户行为和动作导致状态转移。难以描述协同发起的攻击行为，所以引入着色Petri网



### 异常入侵检测

异常入侵检测系统：可以发现未知的攻击模式，漏报率低。需要训练

基于统计分析的异常入侵检测：

- 操作模型：观测到变量X出现的次数是否超过某个预定的值
- 均值和标准差模型：根据均值和标准差，观察到系统/用户行为超出了信任区间
- 多元模型：基于对两个或多个系统度量之间的相关分析
- 马尔可夫过程模型：使用正常的状态转移矩阵计算系统实际状态变化的发生概率，如果概率非常小则认为出现异常
- 时序模型
- 目标完整性检查模型：使用hash计算系统中某些关键的对象的摘要，看是否被修改

基于神经网络的入侵检测：矩阵运算，训练获得。不一定有解

------

## 第九章 入侵检测安全响应

一旦发现了攻击，要做出回应。针对攻击者：阻断攻击行为或反击，收集攻击信息，入侵来源追踪；针对被攻击系统：恢复被攻击系统、网络或服务，系统修正，损失评估

### 入侵检测安全响应技术

阻断攻击：IDS向攻击者和靶机发送TCP RESET，断开连接

收集攻击信息：蜜罐、诱骗、鱼饵技术

入侵追踪：找出靶机到攻击者的连接链。Thumbprint通过检查TCP包中的Payload内容，ASCII码作为命令；Timing-based通过输入停顿作为匹配特征；Deviation-based利用TCP链上的TCP数据包长度大概一致

网络追踪：对于未建立连接的攻击，人工联系前面的各路由器

ICMP追踪：让ICMP报文以一定概率携带报文的内容和下一跳路由器信息

基于日志的追踪：由路由器计算并保存每个数据包的Hash摘要

PPM：路由器以一定概率对数据包进行标记，说明该数据包经过了哪一些路由器

### 入侵检测发展

------

## 第十章 数据备份与灾难恢复

应急计划（Contingency Plan，CP）：一个组织具备承受各种灾难，并在灾难引起环境变化中，保持主要任务顺利运行的能力。

NIST SP800-53 中的应急计划

- 应急计划的策略和过程
- 应急计划
- 应急训练

业务连续性相关计划BCP：实现在故障或灾难中业务的恢复和保持

------

## 第十一章 拜占庭容错系统

入侵容忍：如果系统在遭受特定程度的攻击时仍能够正确运行，系统的安全性将大为增加。入侵容忍有两个途径：攻击响应，加快反应速度；攻击遮蔽，包括拜占庭容错技术、门限密码技术

### 拜占庭将军问题BGP

用于解决集群中节点故障问题

背景：超过半数的将军选择进攻A，则所有将军都要进攻，撤退R同理。只有所有人进攻才能攻下来城堡，那么如何保证成功？

#### 方案1：口头消息（必考）

将军-副官模型（BGP，Byzantine Generals Problem）：将问题简化为一个将军向其他n-1个副官发信息的情况。

每个副官i将自己收到的信息vi发给其他人，每个人将自己收到的所有消息取majority（少数服从多数）作为自己的行动，再将所有人行动统一。**注意：如果选择进攻和撤退的人数相同，那么默认撤退！**

[拜占庭将军问题深入_castle的技术博客_51CTO博客](https://blog.51cto.com/u_11257187/2123069)

结论：3m+1个人中最多可以有m个叛徒。

两个要求：

- 一致性：所有忠诚的副官必须要进行相同行动
- 正确性：如果将军是忠诚的，那么所有忠诚的副官都要执他的命令；如果将军是叛徒，则忽略此要求

m=1, n=4：[拜占庭将军问题之口头协议 - 走看看 (zoukankan.com)](http://t.zoukankan.com/jockming-p-12096288.html)

一个例子：

- 假设n=7,m=2，将军是0号，5号和6号是叛徒，将军发出进攻A命令。由于1号不知道将军是不是叛徒，所以需要询问其他人的看法，所以列出一张**1号的决策表**a。
- 其中$a_{ij}$表示$j$告诉1号【$i$号给他发的什么命令】，第i行的第一列对后面所有列取majority，这样$a_{i1}$就是1从i获得的真实命令；最后对第一列取majority，即可计算出1的行动。（a11代表将军给1号的命令）
- 注：由于存在叛徒，他们可能会随意回应，所以用小写字母表示未知量

| V1=A | V2   | V3   | V4   | V5   | V6   |
| ---- | ---- | ---- | ---- | ---- | ---- |
| V2=A | A    | A    | A    | a    | b    |
| V3=A | A    | A    | A    | c    | d    |
| V4=A | A    | A    | A    | e    | f    |
| V5=x | g    | h    | i    | j    | k    |
| V6=y | l    | m    | n    | o    | p    |

由上表可知，第一列的majority是A，所以1号最终选择进攻。**每个副官都需要建立一张决策表来计算最终决策**

流程：设m为叛徒数，n为全部人数。初始情况m个叛徒时记作OM(m)，操作如下

- 首先将军向所有副官发送命令v；
- **递归步**（发）：每个副官j收到将军的命令后，**j在OM(m-1)中作为将军**，将自己获得的命令vj发给其他n-2个副官（但是其他的每个人i并不是直接从j处获得的vj，而是通过除了i、j的其他n-3个副官告诉i【j给他们发的命令是什么】，取majority作为vj，也就是列表的过程）；
- 问：i要行动时，由于不确定将军是不是叛徒，需要向其他n-2个副官询问他们获得的命令，经过第二步得到一个向量(v1,v2,...,vn-1)，而vj就是i在第二步中从【**j作为将军进行OM(m-1)发送命令时**】收到的命令，取majority作为i最终的执行动作

只要每次悲观认为将军是叛徒，那么OM(m)就下降一层到OM(m-1)。直到m=0时，将军一定是忠诚的，那么每个副官就直接执行将军的命令。

复杂度：由于每个副官都要调用一次OM(m-1)，一共n-1个副官，所以OM(m)调用n-1次OM(m-1)；OM(m-1)调用n-2次OM(m-2)...总而言之，OM(m)调用(n-1)...(n-m)次OM(0)，因此时间复杂度为$O(n^m)$。

#### 方案2：签名消息

将军和副官对消息签名再发给别人，每个副官维护一个带签名的消息集合，集合中消息数量大于m时，执行majority操作



### 拜占庭容错系统BQS

拜占庭容错系统BQS（Byzantine Quorum Systems）：在分布式、异步传输网络环境中，利用复制技术排除攻击者的影响

假设一共n台服务器，最多可能有f台服务器失效，为保证容错将数据复制到q个服务器分别存储，最后任意读q个服务器就能得到正确的数据。BQS探究n、f、q之间的关系

数据格式：[x, v, t]，表示变量x，值为v，时间戳为t

- 读：client向所有server发送读命令，**任意读q个服务器**的[x, v, t]，从中选出合适的结果。这些server记为Qr
- 写：client向所有server发送写命令[x, v, t]，直到收到**q个server确认**。这些server记为Qw

安全条件：

- 可用性：$n-f\ge q$，保证在f个server失效的情况下，正确的server数超过q，否则不够读q台的
- 一致性：$q\ge(n+2f+1)/2$。希望Qw和Qr的交集越大越好，保证读出的结果是最近一次写入的结果。最好情况下，交集=q；最坏情况下交集=q-(n-q)=2q-n。又因为在交集中采用majority必须保证正确的占到一半以上，所以2q-n>=2f+1，所以q>=(n+2f+1)/2
- 解方程可知，n>=4f+1，q>=3f+1

自验证数据：从自身就可以验证其有效性的数据。可以减少n

---

## 第十二章 门限密码学

将一个密码操作分散到一个群体来执行，基础是秘密分享机制

### 秘密分享方案

秘密分享：将秘密S拆分成n个份额$s_0,...,s_{n-1}$，通过门限t个份额可以恢复出S，而t-1个份额不行

(t,n)秘密分享方案

- (n,n)分享：将S分成t份，每个si都是S减去其他sj之和的结果
- (t,n)分享：将S做n次(t,t)分享，即使用n种方法来拆分S，最后每个人维护t个份额

Shamir秘密分享方案：t-1阶多项式曲线$F(x) = a_{t-1}x_{t-1}+… +a_1x + a_0$，t个坐标才能恢复原曲线，每个参与者的份额就是一个坐标$(x_i,F(x_i))$。将常数项$a_0$设定为秘密S，使用拉格朗日插值公式计算$a_0$：
$$
s=a_0=\sum_{j=1}^{t}[F(x_j)\prod_{i\ne j}\frac{x_j}{x_i-x_j}]
$$


层次型秘密分享：每个分享者拥有不同份额

联合秘密分享：适用于没有分发者的情形

- 每个人i自己的秘密为$s_i$，并构造一个自己的多项式$F_i(x)$，即$F_i(0)=s_i$
- i对于其他n-1个人j，计算出n-1个值$F_i(j)$，并分别发给他们
- i收到其他n-1个人计算出的n-1个值$F_j(i)$，求和作为自己的份额
- 共享秘密$S=\sum s_i \mod{q}$

敌手模型：敌手最多可攻击n个人中的t个，攻击包括窃听、终止、恶意

Proactive Recovery：在攻击者控制足够多的、足于威胁系统安全性的组件之前，抢先地将全部各组件都重新恢复到初始状态。具体来说周期性地重新拆分秘密S

0秘密分享

可验证的协议：可以验证份额的正确性

### 基于秘密分享的门限密码学

门限签名：多个人的签名合成一个完整的签名，才有效

- 每个参与者得到不同的部分私钥di
- 每个参与者使用自己的部分私钥di参加计算，得到部分签名结果
- 将多个部分签名结果合成，得到完整的数字签名

RSA算法的私钥签名：没有引入门限

- 将私钥d拆分成$d=d_1+d_2+d_3$
- 部分签名$P_i=C^{d_i}\mod{n}$，也就是份额
- 合成完整的签名$P=P_1P_2P_3=C^{d_1+d_2+d_3}\mod{n}$



APSS的私钥拆分：设$L=C_n^f$组合数，将私钥d拆解为L个随机数（部分私钥）之和$d=d_1+...+ d_L$，对应L个子集，每个集合对应f个人的一种组合
$$
S_1=\{s_1,s_2,...,s_f\}\\
S_2=\{s_2,s_3,...,s_{f+1}\}\\
...
$$
$d_k$分配给除了$S_k$中元素以外的所有人。这样随便来f个人，总能属于一个子集Sk，而他们都没有dk，再来一个人就有dk了，即可还原出d来



RSA对中模幂算法的门限计算方法，实际上是对秘密和的分享，即直接对份额进行和/差操作即是对秘密和/差的分享

对于更复杂的密码算法或协议（例如，DSA，digital signature algorithm），则需要对更多操作的秘密分享，乘积和逆

### DSA的乘积、逆秘密分享

- 设私钥为x，公钥为y。参数p、q、g双方共享
- 签名生成：设明文为M。产生随机数k，r=(k,p,q,g)，s=(k,M,x,r,q)，(r,s)作为签名结果
- 签名验证时：v=(r,s,p,q,g,M)，若v=r则通过验证

要想签名有效，就要保证x,k不被泄露，因此计算秘密s的合成时，需要用到乘积、逆的门限计算。保证可以多人合成s的同时，又不暴露每个人自己的ki和xi

秘密乘积的门限计算：每个人将自己的ki和xi相乘，实现对kx的分享。此时的分享多项式为$f_kf_x$，阶数为$2(t-1)=2t-2$，因此需要$2t-1$个参与者才能恢复出秘密。

秘密逆的门限计算：假设参与者i的份额是$u_i$，参与合成秘密u。现在希望不暴露u的情况下（参与者不知道u是多少），参与者合成计算出秘密u关于q的逆元c，即$c=u^{-1}\mod{q}$。

- 参与者执行t-1阶联合秘密分享，份额为$v_i$，分享一个随机秘密$v$
- 至少2t-1个参与者执行乘积的分享，广播自己的份额$(uv)_i=u_iv_i$
- 参与者通过其他人广播的$(uv)_i$计算出$uv$，并计算出自己关于c的份额$c_i=(uv)^{-1}v_i \mod{q}$。（这是因为$(uv)^{-1}$只是一个系数，t个参与者合成的结果就是$(uv)^{-1}v=u^{-1}=c$）

---

## 第十三章 自重构可信赖与终端安全

自重构可信赖技术：在复杂的网络环境中，根据应用需求，在规模、粒度、位置、时间和信赖程度等多个方面按照安全要求，动态地建立起可以被证明的适度可信赖的路径和子网络。

终端安全

Linux主要安全机制

- 自主访问控制DAC
- 强制访问控制
- Sec comp机制：限制系统调用
- Namespace隔离机制：将系统的全局资源放入不同的namespace中，docker的容器就是一个独立的空间
- KASLR：内核地址空间布局随机化，使得内核每次启动后，数据段映射的地址都不一样，内核漏洞难以利用
- 系统完整性度量：在系统加载之前，ROM代码验证OS代码完整性

------

## 第十四章 可信计算技术及其发展

### 可信计算

可信计算：假定客户端软件可能被破坏的情况下，保护敏感信息，不被窃取或者不被恶意代码使用。可信计算组织TCG（Trusted Computing Group）负责制定相关标准。可信计算的核心是TPM（可信计算模块），为软件客户端提供信任锚

可信计算的安全功能

- 密码功能：采用硬件方式，使用非对称密码来认证
- 完整性度量：检查平台配置寄存器PCR度量值的变化，发现恶意程序
- 证明功能：TPM私钥对软件签名，证明软件安全

### TPM

可信平台模块TPM（Trusted Platform Module）是可信计算的基础，功能：

- 安全证明所引导的环境：可信记录软件的启动过程，使用平台配置寄存器PCR（Platform Configuration Register）记录系统启动序列。从信任根（系统中第一个获得控制权的模块，启动BIOS）开始构建信任链，每个节点都是镜像的哈希值（度量值）
- 安全地存储数据
- 安全地标示用户和系统
- 支持标准的安全协议
- 在同一系统上为多个用户提供各自的安全保障

TPM安全存储：对称密钥存储、非对称密钥存储。使用链式存储，根为背书密钥SRK密钥

安全签名



BIOS访问TPM

TDDL

TSS（TCG软件栈）架构：

- TCG设备驱动程序库TDDL（TCG device driver library）
- TCG核心服务TCS
- TCG服务提供者TSP

CRTM静态可信根（core root of trust for measurement）

DRTM动态可信度量根

TE

可信启动和安全启动

TEE

## 第十五章 安全测评

密码模块：硬件、软件、固件，或它们之间组合的集合。该集合至少使用一个核准的密码算法、安全功能或过程来实现一项密码服务，并且包含在定义的密码边界内。

FIPS（Federal Information Processing Standards，联邦信息处理标准）里面定义了密码模块标准

密码模块：实现密码功能的部件

密码模块5种类型：硬件密码模块、软件密码模块、固件密码模块、混合软件模块、混合固件模块

通用准则CC：一种描述产品信息安全要求的语言，开发 安全保护轮廓PP+安全目标ST

- 评估目标TOE
- 安全目标ST（Security Target）：对某个特定的评估目标TOE提出的要其满足的安全功能要求（特定产品）
- 保护轮廓PP（Protection Profile）：对某一类产品提出的安全功能和安全保障要求（一类产品）

CC的两类安全要求

- 安全功能要求SFR（Security Functional Requirements）：用于定义信息产品的安全功能
- 安全保障要求SAR（Security Assurance Requirements）：确保信息产品的安全功能可以被有保障的实施

评估将在特定的安全功能要求SFR上选择适合产品自身条件和产品用户要求的安全保障需求SAR，或者选择预定义的安全保障级别（EAL，Evaluation Assurance Level）
