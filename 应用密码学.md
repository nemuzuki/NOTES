###  第一章 密码学概述

密码系统（明文空间P，密文空间C，密钥空间K，加密算法E，解密算法D）

对称加密：加密密钥=解密密钥；如密钥流：明文异或密钥得到密文，密文异或密钥得到明文；缺点：每两个人之间都需要一个密钥，总数为n*(n-1)

非对称加密：B生成公私钥对，将公钥公开，A用公钥加密明文发给B，密文由B用私钥解密。每个人只有一个公钥和私钥，总数为2n

密码系统的安全性：依赖于密钥的秘密性，而不是用什么算法的保密性；破译是NP难问题

可信密码学问题：因数分解、离散对数

安全性证明：给出加密算法和所依赖的可信密码学问题之间的规约关系

秘密共享：希望n个人里任意m个人合作获取密钥K，只需定义m-1阶多项式，K作为常数项，这样n个点取m-1个用插值公式即可恢复多项式

数字签名：私钥加密得到数字签名，公钥解密，证明身份

Diffie-Hellman密钥交换协议：

- Alice产生随机数xa，计算$y_a=g^{x_a} \mod p$，将ya发给Bob；Bob产生随机数xb，计算$y_b=g^{x_b} \mod p$，将yb发给Alice；共享密钥$K=y_b^{x_a} \mod p=y_a^{x_b} \mod p$
- 攻击者直到p, g, ya, yb，无法求xa, xb, K
- 可能中间人攻击，C在AB之间互相冒充

Needham-Schroeder协议

身份认证协议的要求：零知识证明，A能向B证明自己，但B不能获得A的任何信息以假冒A。
基于公钥密码的身份验证：Alice发一个随机的R给Bob，Bob用私钥加密R得到Y给Alice，Alice用**Bob的公钥**（公钥即身份）解密得到R'，若R=R'则鉴别了Bob的身份。R必须随机，否则别人可以记录Y发给Alice，冒充Bob

密码学的层次结构

- 计算困难性问题，假设P!=NP
- 难解问题作为密码学基本构件，解决任务
- 构件组成密码协议
- 安全系统

云计算：共享的软硬件资源和信息可以提供给其他计算机

可验证计算：保证远程服务器正确执行了所要求的计算

密文计算技术：希望数据外包但不被泄露

同态加密：使得先运算再加密=先加密再运算的加密函数，人们可以委托第三方对数据进行处理而不泄露信息。RSA具有乘法同态性

代码混淆：在软件中隐藏秘密如密钥、程序漏洞

#### 攻击类型

- 被动攻击 流量分析、监视未受保护的通信等
- 主动攻击 企图破坏或攻击保护措施、引入恶意代码以及偷窃或修改信息。
- 物理临近攻击 以更改、收集或拒绝访问信息为目的而在物理上接近网络、系统或设备。
- 内部人员攻击 分为恶意的或非恶意的。非恶意的包括误用或训练不足导致的攻击
- 分发攻击 在工厂内部或在产品分发过程中恶意修改硬件或软件。

------

### 第二章 经典密码学

#### 1.替换密码体制

凯撒密码/移位密码：每个字母向后移K位，密钥空间为26，加密规则是$e_K(x)=(x+K)\mod 26$

乘数密码：密码$j = k\cdot i \mod q$。因为j可以为1，根据定理，k必须和q互素（gcd只有1），q=26时，k的密钥空间为12（小于26且与26互素的个数）

仿射密码

多表替换密码
Vigenere维吉尼亚密码：给一个长为len2的密钥字符串K，对明文P的每个字母后移K[i]-'a'，i超过len2则回滚

```python
# 加密，默认明文和密钥都是大写字母
def encrypt(text: str, key: str) -> str:
    cry = ""
    n = len(text)
    m = len(key)
    for i in range(n):
        pos = (ord(text[i]) - ord('A') + ord(key[i % m]) - ord('A')) % 26
        cry += chr(pos + ord('A'))
    return cry


# 解密
def decrypt(cry: str, key: str) -> str:
    text = ""
    n = len(cry)
    m = len(key)
    for i in range(n):
        pos = (ord(cry[i]) - ord('A') - ord(key[i % m]) - ord('A') + 26) % 26
        text += chr(pos + ord('A'))
    return text
```



#### 2.置换密码体制

置换密码：重新排列明文

Hill密码：将明文M=m1m2...mt左乘一个方阵转换为密文C
$$
\begin{bmatrix}
 c_1\\
 c_2\\
 ..\\
 c_t
\end{bmatrix}
=
\begin{bmatrix}
 k_{11} & k_{12} & ... & k_{1t}  \\
 k_{21} & k_{22} & ... & k_{2t}  \\
 ..\\
 k_{t1} & k_{t2} & ... & k_{tt}  \\
\end{bmatrix}
\cdot
\begin{bmatrix}
 m_1\\
 m_2\\
 ..\\
 m_t
\end{bmatrix}
\mod 26
$$


#### 3.经典密码体制分析

（1）利用英文字母频率统计

（2）Vigenere密码分析：利用统计学破解Vigenere密码

重合指数$I_c(X)$：一个字符串X中任选两个字符相同的概率。设$p_1,...,p_{26}$为字母a-z的出现次数
$$
I_c(X)=\frac{\sum_{i=1}^{26}C_{p_i}^2}{C_n^2}=\frac{\sum_{i=1}^{26}p_i(p_i-1)}{n(n-1)}
$$
自然语言的重合指数为0.065，随机字符串的重合指数为0.038

i)利用重合指数猜测密钥长度：

- 首先猜测密钥长度为k，将密文分成k组，每组内的每个字母在密文中间隔为k
- 对每组计算重合指数，所有组相加取平均得到密钥长度为k下的总重合指数
- 找到最大重合指数时的k，就是最可能的密钥长度

ii)猜测密钥内容

- 对划分出的每组，选定26个字母中的一个，计算出加密前的字母，统计字母频率，和自然语言的字母频率表做内积，内积最大时的字母就是密钥

互重合指数$MI_c(X,Y)$：在字符串X和Y均任取一个字符相同的概率。
$$
MI_c(X,Y) = \frac{\sum_{i=1}^{26}{f_ig_i}}{mn}
$$
互重合指数的期望：设字符串Y由X每个字符移动n位得到，即它们的相对位移为n，n∈[0,13]。对不同n，计算X,Y的互重合指数，来判断到底移动了几位

作业：9.27之前交

（1）求Hill密码的密钥空间

（2）解密单表和多表替换

------

### 第三章 信息论基础

#### 1.概率论基础

密码系统（明文空间P，密文空间C，密钥空间K，加密算法E，解密算法D）

已知明文分布、密钥分布，根据贝叶斯公式，
$$
p(明文x|密文y)=\frac{p(x)p(y|x)}{p(y)}
$$
#### 2.完善保密性

如果对任何x,y，p(x|y)=p(x)，则称具有完善保密性。收到密文y后，x的后验概率=先验概率

移位密码：如果每个密钥等概率使用，则具有完善保密性

完善保密的充要条件

维尔南Vernam一次一密体制：明文和密钥等长，异或得到密文。密钥太长

#### 3.自信息、熵

随机事件的自信息：$I(x_i)=-\log p(x_i)$，底数为2时单位为bit。不确定性越高，信息量越大
n位2进制数有2^n种组合，每种的自信息=-log(1/2^n)=n bit
条件自信息量I(x|y)=I(x,y)-I(y)

信息熵：随机变量X的熵=各事件自信息的加权平均。物理含义是编码一个事件的平均比特数
$$
H(X)=-\sum_{i=1}^n p(x_i)\log_2 p(x_i)
$$
联合熵
$$
H(X,Y)=-\sum_{i,j}p(x_i,y_j)\log_2p(x_i,y_j)
$$
条件熵
$$
H(X|Y)-\sum_{i,j}p(x_i,y_j)\log_2p(x_i|y_j)
$$


熵是凸函数，琴生不等式：$avg(H)\le H(avg)$，当且仅当各事件概率相同取等
H(X)<=log2n，当且仅当pi=1/n

从熵的角度解释完善保密性：H(P)=H(P|C)

密钥暧昧度：已知密文的情况下泄露多少密钥信息的度量，$H(K|C)=H(K)+H(P)-H(C)$

#### 4.伪密钥与唯一解距离

自然语言的熵$H_L$：n个字符的明文全体的熵/n，每个字符的平均信息量

自然语言的冗余度：每个字符的冗余信息量$\log_2{26}-H_L$，有冗余度才能破解密码

伪密钥：能把密文解密为有意义的明文，但不正确

伪密钥的期望个数有下限$2^{H(K)-nD}-1$，当截获的密文量大于唯一解距离n0，原则上就不存在伪密钥，只要解密出的明文有意义，就等于破译了密码

#### 5.乘积密码体制

满的密码体制：明文空间=密文空间

乘积密码体制：先用K1加密，再用K2加密

---

### 第四章 数学基础

#### 1.数论基础

整除：a是b的倍数，即b整除a，a被b整除，记作$b|a$

任何一个数有唯一的素数分解，$a=p_1^{a_1}p_2^{a_2}...p_t^{a_t}$

素数的个数无穷。否则它们相乘+1仍然是素数

##### 最大公约数

- $\gcd(a,b)=\gcd(a,-b)=\gcd(a,a-b)$
- 求gcd：辗转相除法/更相减损术
  
- 裴蜀定理：对任意正整数a,b，一定存在$x,y$，使得$ax+by=gcd(a,b)$，即gcd一定是a, b的线性组合，且为最小的正整数线性组合
  
- a, b互素：最大公约数为1，1是a, b的线性组合（$\exist x,y\in \Z$，使得$ax+by=1$）

同余：若$a \pmod{n} = b \pmod{n}$，则称a与b模n同余



##### 乘法逆元

如果$ab \equiv 1 \pmod{n}$，则b是a模n的乘法逆元。**乘法逆元不一定存在，存在的充要条件是a和模数n互素**

欧拉定理：若正整数a与n互素，则$a^{\varphi(n)}\equiv 1 \pmod{n}$

费马小定理：可以用来求乘法逆元。设p为素数，a为正整数且与p互素，则$a^{p-1} \equiv 1 \pmod{p}$，也就是说$a^{p-2}a \equiv 1 \pmod{p}$，即$a^{p-2}$就是a模p的乘法逆元

同余方程解的个数问题



##### 扩展欧几里得算法

用于求a模b的逆元，ax mod b = 1 （用于RSA已知公钥e和phi(n)求私钥d）

求裴蜀定理的系数x,y：ax+by=gcd(a,b)

递归的原理：每一层的x1,y1由栈深一层的x2,y2得到
$$
\because ax_1+by_1=gcd(a,b)=gcd(b,a\%b)=bx_2+(a\%b)y_2\\
\because a\%b=a-a/b*b\\
\therefore ax_1+by_1=bx_2+(a-a/b*b)y_2=ay_2+b(x_2-a/b*y_2)\\
\therefore x_1=y_2 , y_1=x_2-a/b*y_2
$$

```cpp
int x,y;
//求最大公约数
int exgcd(int a,int b){
    if(b==0){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b);//先求最大公约数
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}
```

递归最深处为b=0时，此时a是gcd；之后一层层向上拨开，不断更新每层的x,y，直到出口。最后的x既是裴蜀定理的a前系数，又是a模b的乘法逆元（如果存在乘法逆元的话，即a和b要互素），因为ax+by=1等价于ax mod b=1

##### ※中国剩余定理的原理

解同余方程组
$$
\left\{\begin{matrix}
 x \equiv a_1 \pmod{m_1} \\
 x \equiv a_2 \pmod{m_2} \\
 \vdots\\
 x \equiv a_k \pmod{m_k}
\end{matrix}\right.
$$
解为
$$
x=\sum_{i=1}^k M_ie_i a_i \pmod{M}
$$
其中
$$
M_i=\frac{M}{m_i}\\
M_ie_i\equiv1\pmod{m_i}
$$
思路是：希望求出一个数$\frac{M}{m_i}e_i a_i$，显然它模mi为ai，模其他mj为0（上式两边同乘ai）。把这样的k个数加起来，就是最终结果。

注意到乘法逆元的定义，$M_i M_i^{-1}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \equiv 1 \pmod{m_i}$，如果用扩展欧几里得算法求出Mi模mi的逆元，将它作为$\frac{M}{m_i}e_i a_i$即可。

显然，将这些结果相加，得到的数满足同余方程组



##### ※利用矩阵初等行变换实现扩展欧几里得

扩展欧几里得算法可以用来求裴蜀定理中的x,y：$ax+by=\gcd(a,b)$，以及计算a模b的乘法逆元（如果存在的话）。此处用简单的矩阵初等行变换进行计算

- 构造一个2x3的矩阵，左边是a,b，右边是2x2单位矩阵
- 通过行变换（减去另一行的**整数倍**，就是欧几里得算法中不断相减）使得左下角或者左上角为0，则另一个角就是gcd(a,b)，gcd行右边的两个元素就是x,y。
- 如果a存在模b的乘法逆元，那么逆元就是x（但是x经常是负数，需要再加上一个b）

![](pic/crypto/扩展欧几里得.png)

```
图中将a,b写在上方，实际写在左边也可
由于240和46不互素，所以没有乘法逆元
```



原理：

令$r_{-1}=b,r_0=a$，根据扩展欧几里得算法，a和b的更新要根据递推式
$$
\begin{pmatrix}
 r_0\\
 r_{1}
\end{pmatrix}
=
\begin{pmatrix}
 0 & 1\\
 1 & -q_{1}
\end{pmatrix}
\cdot
\begin{pmatrix}
 r_0\\
 r_{-1}
\end{pmatrix}
$$
于是有：（不妨设左侧的连乘结果为一个2x2的矩阵Mn）
$$
\begin{pmatrix}
 r_n\\
 r_{n+1}
\end{pmatrix}
=
\prod_{i=1}^{n}
\begin{pmatrix}
 0 & 1\\
 1 & -q_{i}
\end{pmatrix}
\cdot
\begin{pmatrix}
 r_0\\
 r_{-1}
\end{pmatrix}
=M_n\cdot
\begin{pmatrix}
 r_0\\
 r_{-1}
\end{pmatrix}
$$

而又有边界条件$r_n=(a,b),r_{n+1}=0$（b=0时退出迭代），于是
$$
\begin{pmatrix}
 r_n\\
 0
\end{pmatrix}
=M_n\cdot
\begin{pmatrix}
 a\\
 b
\end{pmatrix}
$$
Mn的第一行就是p,q。等式左边右拼Mn，等式右边右拼单位矩阵，有
$$
\begin{pmatrix}
 r_n & M_n & M_n\\
 0 & M_n & M_n
\end{pmatrix}
=M_n\cdot
\begin{pmatrix}
 a & 1 & 0\\
 b & 0 & 1
\end{pmatrix}
$$


#### 2.群的基本概念

##### 群

群：是一个集合。非空集合G上的一种二元运算$a\circ b$，如果满足下面三点，就称G在运算$\circ$下是一个群

- 结合律$a\circ (b\circ c)=(a\circ b)\circ c$
- G中有一个**单位元**e，满足$a\circ e=e\circ a=e$
- 每个元素都有**逆元**，$a\circ a^{-1}=a^{-1}\circ a=e$

阿贝尔群（加法群）：满足交换律的群。整数在加法运算下是个阿贝尔群。

群的阶：元素个数

有限群：元素个数有限

子群：群G的子集H在G的运算下仍构成群

循环群：循环群G中任意元素$b=a^t$，则称a为G的**生成元**

元素a的阶：

- 满足$a^k=e$的最小正整数k
- 如果\<a>是有限群，则\<a>的阶=a的阶，否则a为无限阶

关系：一些元素对(a,b)的集合
等价关系：满足自反性、对称性、传递性
等价类

拉格朗日定理：设H是G的子群，那么H的阶整除G的阶

同态映射：两个群一一映射

##### 陪集、商群

陪集：设H是群G的一个子群，$a\in G$，集合$Ha={\{ha|h\in H\}}$称为**H在G中的一个右陪集**，aH称为H在G中的一个左陪集。若对于所有$a\in G$，有$aH=Ha$，则称H是G的一个**正规子群**。（注：这里的运算$\circ$被简写省略了）

商群$G/H$：若H是G的一个正规子群，则用$G/H$表示**H在G中的所有陪集（形如aH,bH等）组成的集合**，称为**G关于H的商群**



#### 3.环和域

##### 环

环R：在群之上，有加法和乘法两种运算

- 关于加法是交换群
- 关于乘法满足结合律
- 满足分配律

交换环：满足乘法交换律的环

整环：

- 是交换环
- 有乘法单位元，且不为0
- 无零因子：若$a\ne 0,b \ne 0$，则$ab\ne 0$

除环：一个环，其中所有非零元在乘法下构成群，即任何非0元素都有乘法逆元

##### 域

域：有乘法逆元的整环。域在环的基础上，还要求乘法满足交换律、有单位元、有逆元、无零因子，也就是说域关于加法和乘法都是交换群，乘法逆元这个条件使得域对于四则运算都是封闭的，有理数、实数、复数集合都属于域（当然整数集合只是环不是域，因为相除会得到分数）。

域的特征：如果存在正整数p使得$p\cdot 1=0$（1是乘法单位元），那么把最小的p称为域的特征。域的特征p一定是0或素数，假设$p=hk$，那么$0=p\cdot 1=(h\cdot 1)(k\cdot 1)$，所以$h\cdot 1=0$或者$k\cdot 1=0$，这与p最小矛盾。

进一步，特征为p且有素数p个元素，形如$\{0,e,2e,...,(p-1)e\}$的域就称为素域。

##### 理想

理想（ideal）：设$I$是环R的一个子环，如果**R中任意元素与I内元素相乘都属于I**，即$r\in R,x\in I \Rightarrow rx\in I,xr\in I$，则称$I$是R的一个理想

包含a的最小理想$(a)=\{ra+na|a\in R, n \in Z\}$

主理想：设$J$是R的一个理想，如果存在$a\in R$使得$J=(a)$，那么J称为由a生成的主理想

主理想整环：若R是一个整环，且R的所有理想都是主理想，则称R是主理想整环

素理想：若ab属于理想P，能推出a和b属于理想P，则称P是素理想。p是素数，那么p|ab，则有p|a或p|b

##### 商环

剩余类：设I是R的一个理想，定义R中元素的等价关系$a\sim b\Leftrightarrow a-b\in I$，这种等价关系将R分成了若干互不相交的等价类的并，每个等价类叫做模$I$的剩余类，剩余类$[a]$中的元素都有形式$a+c,c\in I$。

剩余类环：商集$Z_m=\{[0],[1],...,[m-1]\}$关于加法运算$[a]+[b]=[a+b]$和乘法运算$[a][b]=[ab]$构成一个环，称为模m的剩余类环。

商环$R/I$：设R是一个环，$I$是R的理想。现在只关注加法，R是一个群，又因为理想的定义，所以I是R的一个正规子群，那么I在R中所有陪集$r_i+I$（将陪集定义中的$\circ$换成加法）组成的集合$R/I$是一个商群（因为是关于加法的，所以称为加法商群）。在其之上定义乘法$(a+I)(b+I)=ab+I$后，$R/I$是一个环，称为**$R$关于理想$I$的商环**

在同余关系中，$[a]$相当于所有模c为a的元素的集合，这些元素之间只差c的倍数，而$I$是c的倍数的集合。那么一个陪集$r_i+I$就是模c为ri的元素的集合，也就是$[r_i]$，所以陪集们组成的集合$R/I$正是剩余类环。因此，在定义加法$(a+I)+(b+I)=(a+b)+I$和乘法$(a+I)(b+I)=ab+I$后，商环=剩余类环！

##### 多项式环

设R是一个数环，$R[x]$表示系数属于R的所有x的多项式构成的集合，则R[x]关于多项式的乘法和加法构成一个环，称为R上未知量x的多项式环

#### 4.有限域

有限域$GF(p)$代表有p个元素的有限域。有限域的元素个数一定是一个素数的幂，所以记为$GF(p^n)$，一般只关注两种情况：

- n=1时$GF(p)$的空间是模p的完全剩余类$Z_p:\{0,1,...,p-1\}$
- p=2时$GF(2^n)$中的元素是系数为0或1的多项式，最高不超过n-1次

$GF(p)$域和$GF(2^n)$域中的元素都可以用多项式表示

- 如果系数在$GF(p)$中，多项式在运算时，最后结果的系数要进行模p操作
- $GF(2^n)$域上的多项式运算时，系数对2取模，并且多项式对n次素多项式取模。使用扩展欧几里得算法来求逆，主要用于AES

##### 多项式模运算

竖式运算，不断减x倍即可

##### 多项式求逆

例如：求解$GF(2^8)$上的多项式乘法逆，(09)H mod x^8+x^4+x^3+x+1
(09)H=1001=x^3+1。可以用扩展欧几里得的矩阵初等变换法来求解

构造矩阵
$$
\begin{pmatrix}
 x^8+x^4+x^3+x+1 & 0 & 1\\
 x^3+1 & 1 & 0
\end{pmatrix}
$$
初等变换，即不断让r11和r21乘x相减使得左上角或者左下角为0，注意减法也是异或。得到
$$
\begin{pmatrix}
 0 & * & *\\
 1 & x & x^6+x^3+x^2+x+1
\end{pmatrix}
$$
所以，$x^3+1$的逆元为$x^6+x^3+x^2+x+1$，二进制为1001111=0x4F



分裂域

Fq的本原元：Fq*的生成元

共轭元：$F_{q^m}$是Fq的扩域，$\alpha,\alpha^q,...,\alpha^{q^{m-1}}$是$\alpha$相对于Fq的共轭元

元素的迹：$\alpha$所有共轭元素之和
$$
Tr_{F/K}(\alpha)=\alpha+\alpha^q+...+\alpha^{q^{m-1}}
$$
本原多项式



---

### 第五章 流密码与LFSR序列

#### 流密码的加密模型

Vernam密码：一个随机的二元（01）密钥流序列，与明文序列异或，得到密文序列。那么什么是随机？

二元序列的周期：如果对二元序列a，存在最小正整数l，使得每个$a_k=a_{k+l}$，则l是a的周期p(a)

游程：设二元序列a的一个周期为0111...10或者1000...01，称为1游程和0游程。长为n的0游程：中间有n个0的游程

自相关函数c(t)：在一个周期L内固定一个常数t，将二元序列a的每一位和平移t位后比较，相同为1，不同为-1，求和
$$
c_a(t)=\sum_{i=0}^{l-1}\eta(a_i)\eta(a_{i+t})\\
\eta(0)=1,\eta(1)=-1
$$
Golomb随机性公设（Golomb定义的随机性）：

1. 在序列的一个周期中，当周期为偶数时，0和1的个数相等；当周期为奇数时，个数相差1
2. 在序列的一个周期中，长为1的游程占总游程的1/2，长为2的游程占总游程的1/4，长为3的游程占总游程的1/8...在同样长度的游程中，0游程和1游程大致各占一半
3. 自相关函数c(t)在t=0时最高，t≠0时迅速下降

伪随机序列的定义：如果a是周期为v的二元序列，对一切$t\ne 0(mod \ v)$都有自相关函数c(t)=-1（这表明不能得到任何信息），则称a是伪随机序列。

- 伪随机序列的周期一定是奇数，而且在a的一个周期里，1的个数和0的个数相差1
- 在一个周期中0游程的个数=1游程的个数

流密码（序列密码）：流密码装置有一个记忆单元，依赖时间变化。主要用于网络通信，延迟低

流密码数学描述

#### 线性反馈移位寄器序列LFSR

<img src="pic/crypto/LFSR结构图.png" style="zoom:80%;" />

线性反馈移位寄存器LFSR（Linear Feedback Shift Register）用来生成伪随机的二元序列，即密钥流。LFSR的输出序列{ai}满足递推关系：
$$
a_{n+k}=\sum_{i=1}^n c_i a_{k-i}=c_1a_{n+k-1}+c_2a_{n+k-2}+...+c_na_{n+k-n}
$$
由系数ci可生成两个多项式

特征多项式：高次项系数c1对应反馈端an-1系数
$$
f(x)=x^n+\sum_{i=1}^n c_ix^{n-i}=x^n+c_1x^{n-1}+...+c_n
$$
联接多项式：高次项系数cn对应输出端a0系数，用于BM算法
$$
f(x)=1+\sum_{i=1}^n c_ix^{i}=1+c_1x+...+c_nx^n
$$
#### LFSR的周期

非退化的n级LFSR序列一定是周期序列，由于n级LFSR最多遍历$2^n-1$种状态，所以周期$\le 2^n-1$。周期为$2^n-1$的n级LFSR序列称为m序列

多项式的阶：设f(x)是GF(2)上的多项式，使得$f(x)|(x^n-1)$成立的最小n称为多项式f的阶。而LFSR的特征多项式的阶就是LFSR产生的序列的周期。

极小多项式：设G(f)为由f(x)产生的所有序列的集合，一个序列a存在一个唯一的首一多项式（首项系数为1的多项式）f(x)使得 $a\in G(h)$当且仅当f(x)|h(x)，也就是说只要是能整除f(x)的多项式都可以生成a，那么就称f(x)为序列a的极小多项式。 



序列的迹表达式

左移变换L：$L_i(a)$表示将a左移i位，从$(a_0,a_1,...)$变为$L(a)=(a_1,a_2,...)$

移位相加特性：m序列移位相加仍是m序列

m序列的特性

- 01平衡性
- 游程个数（伪随机性）

 

#### ※Berlekamp-Massey算法

BM算法：给定一个序列，求生成该序列的最短LFSR的长度n，计算线性综合解（能产生序列的阶数最小的**联接多项式**f(x)，LFSR的阶数l）

每一步n计算当前的多项式能否生成下一位（按顺序将高次项系数到低次项系数 和 当前寄存器覆盖范围 做内积），如果能就不变，否则需要修正多项式$f_{n+1}=f_n+x^{n-m}f_m$，m是上一次$l$改变之前的位置。每一步结束后验算当前寄存器能否生成第n位

```
例如序列a为10011
流程：
f0=1, l0=0 //没有寄存器时，连接多项式为1，不能生成a1=1
f1=1+x, l1=1 //当前寄存器长度为1，所以多项式次数为1，为了生成第一位的1，所以最高次项x前系数为1.
f2=f1+x^{1-0}f0=1+x+x=1+0x=1, l2=1 //f1系数*比特=1*1，不能反馈生成第二位0，所以需要修正f，n=1,fn+1要修正为fn+x^{n-m}fm，上一次l发生改变的位置是m=0，ln+1=max{ln,n+1-ln}
f3=f2=1, l3=1 //当前寄存器长度为1，右移到第二位，f2系数*a2=0*0=0，能生成第三位0，所以不用修正f3
f4=f3+x^{3-0}f0=1+x^3, l4=3 //寄存器右移到第三位，f3系数*a3=0*0=0，不能生成第四位1，所以需要修正f4=f3+x^{3-m}fm，m=0，l4=max{l3,4-l3}=3。可以验证此时寄存器覆盖a1,a2,a3，系数(1,0,0)*比特(1,0,0)=1=第四位1，所以计算正确
f5=f4+x^{4-3}f3=1+x+x^3, l5=3 //寄存器长度为3，覆盖第2,3,4位，f4系数(1,0,0)*比特(0,0,1)=0，不能生成第五位1，所以需要修正f5
```



注意：

- 如果序列第一位为1，那么f和l下标要从0开始，n0和m也可能为0

```python
# Berlekamp-Massey算法：输入LFSR序列及周期，输出线性综合解（联接多项式，LFSR阶数）
def bm(a):
    N = len(a)
    n0 = 1
    d = [0 for i in range(N)]
    f = [[0 for i in range(N+1)] for j in range(N+1)]
    l = [0 for i in range(N+1)]
    for i in range(0, N):
        f[i][0] = 1
        d[i] = a[i]
        if a[i] != 0:
            n0 = i
            break
    f[n0 + 1][0] = 1
    f[n0 + 1][n0 + 1] = -d[n0]
    l[n0 + 1] = n0 + 1

    n = n0 + 1
    for i in range(0, n):
        print("f[{}]={}, l={}".format(i, f[i], l[i]))
    while True:
        print("f[{}]={}, l[{}]={}".format(n, f[n], n, l[n]))
        d[n] = 0
        for i in range(l[n] + 1):
            d[n] += a[n - i] * f[n][i]
        m = n-1
        if d[n] == 0:
            for i in range(N+1):
                f[n + 1][i] = f[n][i]
                l[n + 1] = l[n]
        else:
            # 从右向左找m，注意m是可以为0的
            for i in range(n - 1, -1, -1):
                if l[i] < l[i + 1]:
                    m = i
                    break
            for i in range(N+1):
                if i - n + m < 0:
                    f[n + 1][i] = f[n][i]
                else:
                    # 注意这里需要将系数取正，所以模2
                    f[n + 1][i] = (f[n][i] - int(f[m][i - n + m] * d[n] / d[m])) % 2

            l[n + 1] = max(l[n], n + 1 - l[n])
        n = n + 1
        if n == N:
            break
    print("f[{}]={}, l[{}]={}".format(n, f[n], n, l[n]))
    return f[n], l[n]


if __name__ == "__main__":
    seq = list("00101101")
    a = [int(i) for i in seq]
    bm(a)

```

#### 祖冲之算法 ZUC

- LFSR
- 比特重组
- 非线性函数

#### RC4流密码算法

#### 流密码与代数攻击



------

### 第六章 分组密码

#### 分组密码

- 分组密码都是对称加密
- 将明文消息划分成长度为L位的分组M（L=64/128），每个分组在密钥K下变换为与明文组等长的密文序列C。不同明文使用相同密钥加密后的密文必然不同，否则无法解密
- 置换：设f是有限集合S->S的一个映射，如果对于任意u,v，当u!=v时，f(u)!=f(v)，则称f是S上的一个置换
- 设明文长度为m，密文长度为n，一般情况下，m=n，在给定密钥后相当于一个置换

分组密码的设计原则

- 扩散原则：明文和密钥改变一位，密文的多位随之改变。隐蔽明文的统计特性，防止对密钥逐字段进行破译

- 混淆原则：密文和密钥之间的统计特性关系尽可能复杂，即使获取了密文的统计特性也无法推测密钥。使用非线性代替变换

#### DES

DES（Data Encrypted Standard，数据加密标准）：明文分组64bit，密钥64bit（56bit+8bit校验位）

加密过程包括三个阶段：

- 初始置换IP：64位明文，经过初始置换IP进行比特重排（`a[1]=58`表示将原来第58位的数据方换到第1位）。结果分成左右两部分$L_0$和$R_0$，每部分32位

- 16轮迭代：每轮包含扩展置换、子密钥异或、S盒变换、P盒变换

  - 扩展置换：$R_{i-1}$由32位扩展到48位

  - 子密钥异或：与 由密钥K产生的48位的子密钥$K_i$ 异或

  - S盒变换产生32位输出

  - P盒变换，与$L_{i-1}$异或，输出结果作为下一轮的$R_i$，下一轮的$L_i$则是$R_{i-1}$。即
    $$
    L_i=R_{i-1}\\
    R_i=L_{i-1}\oplus F(R_{i-1},K_i)
    $$
    其中F代表一个非线性加密函数

- 逆初始置换$IP^{-1}$：是IP的逆置换，查表换位得到64位密文

扩展置换E：将32位明文每4位一组扩展成6位，每组的第1位是上一组的最后一位，第6位是下一组的第一位，中间4位不变

子密钥的生成：16轮迭代需要16个48位的子密钥。

- PC-1置换：原始的密钥K舍弃校验位为56位，PC-1比特重排，前28位作为$C_0$，后28位作为$D_0$
- $C_{i-1},D_{i-1}$循环左移得到$C_i,D_i$。如果i=1,2,9,16，循环左移1位，否则2位
- PC-2置换：$C_iD_i$56位选取48位作为子密钥$K_i$
- 回到（2）继续算下一轮的子密钥

S盒：是8个确定的矩阵，每个4行16列，用于混淆（非线性变换）。输入48位，每6位一组共8组，作为8个S盒的输入，每个S盒输出为4位。
设输入为$b_1b_2b_3b_4b_5b_6$，令r和c为$b_1b_6$和$b_2b_3b_4b_5$对应的10进制数，那么$S_i[r][c]$的二进制表示就是4位输出。一共得到8x4=32位，作为P盒的输入

P盒：置换操作，是一个确定的矩阵，查8行4列表重排列这些位，用于扩散

<img src="pic/crypto/DES.png" style="zoom:50%;" />

#### 分组密码的工作模式

- 电子密码本模式ECB：明文每次处理64b，每个明文分组用同一个密钥加密，相当于一个巨大的密码本。相同明文分组加密后总相同，不安全
- 密码分组链接模式CBC：加密函数的输入是前一密文分组和当前明文的异或。使得同一明文分组加密后的密文分组不同
- 输出反馈模式OFB：初始向量IV决定第一个分组的移位寄存器，移位寄存器加密后，高j位和明文分组异或得到密文分组，高j位放入下一分组的低j位继续迭代、初始向量是预定义的随机数，保证了同一明文分组加密后的密文分组不同
- 密码反馈模式CFB：每次将j位密文放入下一次的移位寄存器的低j位。如果传输中一个出错，后续都会出错
- 计数器模式CTR：计数器值加密，和明文分组异或得到密文

#### AES

AES（Advanced Encrypted Standard，高级加密标准）：设128位明文分组，128位密钥，此时轮数$N_r=\max(N_b,N_k)+6=10$，其中Nb是状态矩阵的列数，Nk是密钥矩阵的列数

- 首先对128位明文分组每4个字节（32位）一列，组成一个4x4的状态矩阵state，每个元素8bit。state与轮密钥round key异或
- 之后进行$N_r-1$次**轮变换**，包括4个轮函数：字节代替变换sub bytes、行移位变换shift rows、列混合变换mix columns、与子密钥异或add round key
- 最后一轮变换，只执行sub bytes, shift rows, add round key三个操作，不进行列混合变换

字节代替变换sub bytes：矩阵每个元素$ij$（8bit）查询**AES的S盒**，将$S[i][j]$作为输出。AES的S盒是一个16x16的矩阵，每个元素8bit

行移位变换shift rows：对于S盒输出的4x4矩阵，将第i行左移i个字节

列混合变换mix columns：将矩阵每列看成GF(2^8)上的一个多项式，与$c(x)=03x^3+01x^2+01x+02$相乘，再模$M(x)=x^8+x^4+x^3+x+1$.相当于每列左乘一个4x4的特定矩阵（注 ：这里矩阵乘法中的乘法是要模M(x)的，加法是异或）
$$
\begin{bmatrix}
 02 & 03 & 01 & 01\\
 01 & 02 & 03 & 01\\
 01 & 01 & 02 & 03\\
 03 & 01 & 01 & 02
\end{bmatrix}
\cdot
\begin{bmatrix}
 a\\
 b\\
 c\\
 d
\end{bmatrix}
$$


AES密钥编排：如何从初始的种子密钥编排得到每一轮的轮密钥。先由初始密钥得到W[0]到W[3]：W[0]为初始密钥的前4字节，W[1]是5-8字节

- 密钥扩展：将种子密钥扩展到长为$N_b\cdot(N_r+1)$的扩展密钥，这是长为$N_r+1$的序列W，W[i]4字节，第1轮的子密钥为(W[4],W[5],W[6],W[7])，规则：
  - 当i mod Nk=0时，先将W[i-1]左移一个字节，然后字节代替变换，异或轮常量(2^j,0,0,0)，j是轮数-1，异或W[i-Nk]
  - 当i mod Nk!=0时，W[i]=W[i-1]异或W[i-Nk]
- 轮密钥选取：选取$N_b$个字长作为每一轮的密钥

有限域GF(2^8)：元素个数为2^8

有限域$F_{2^8}$可以表示成所有次数<=7的系数为0/1的多项式的集合。m(x)是8次不可约多项式，所以任意一个多项式模m(x)肯定是次数小于等于7的多项式，这些剩余类形成的环与有限域$F_{2^8}$同构，即
$$
GF(2^8)\cong F_2[x]/(m(x))
$$

#### 分组密码分析技术

密码分析：破解加密算法

##### 1.代换-置换网络SPN

代换-置换网络SPN：对于一个16位的明文分组，进行4轮重复操作，每轮包括3个操作：密钥混合、S盒变换、P盒置换。（SPN是相当于是和DES平级的一种加密模型，分析技术只是用来破解SPN的密钥，而不是用SPN代替DES来破解DES）

- 密钥混合：每一轮的输入和子密钥进行异或运算
- S盒代换：将16位的输入分成4组，每4位输入一个4x4的S盒，每个元素4bit。S盒也可以看成一个长为16的map，一个4bit输入对应一个4bit输出。比如选取SPN的S11盒为DES的S1盒的第一行，S12盒是S1盒的第二行，以此类推，分析多少轮就用到几个S盒
- P盒置换：简单进行比特置换，第四轮不使用

![](pic/crypto/线性分析.png)

##### 2.线性密码分析

###### 线性偏移量

假设已经知道一系列随机的明密文对，可以利用输入输出的线性关系来破解密钥。用一个线性表达式来近似表示加密算法输入和输出的关系，线性表达式为u比特的输入X与v比特的输出Y进行异或，结果为0：
$$
X_1\oplus...\oplus X_u\oplus Y_1\oplus...\oplus Y_v=0
$$
也可以把输入输出写在等号两侧
$$
X_1\oplus...\oplus X_u= Y_1\oplus...\oplus Y_v
$$
线性密码分析就是测定**线性表达式成立的可能性$P_L$的大小**。随机选则输入输出时，$P_L=1/2$；如果PL离1/2越远，说明随机性越差，线性密码分析越有效。

**偏差（偏移量）**：线性表达式成立的可能性$P_L$减去1/2，即$P_L-1/2$（不带绝对值！）。偏移量的绝对值越大，说明输入输出的线性越高，线性密码分析越有效



###### 堆积引理

- 考虑两个二进制变量$X_1,X_2$，$p_1,p_2$为它们分别为0的概率，那么它们异或为0的概率为$P_r(X_1\oplus X_2=0)=p_1p_2+(1-p_1)(1-p_2)$。
  令$\varepsilon_1=p_1-1/2,\varepsilon_2=p_2-1/2$，epsilon称为变量的**线性概率偏移量**，则有$P_r(X_1\oplus X_2=0)=1/2+2\varepsilon_1\varepsilon_2$。epsilon的绝对值越接近0，随机性越好
- 堆积引理：对于n个相互独立的二进制随机变量X1...Xn，有

$$
P_r(X_1\oplus...\oplus X_n=0)=\frac{1}{2}+2^{n-1}\prod_{i=1}^n\varepsilon_i=\frac{1}{2}+\varepsilon_{1,2,...,n}
$$

- 由于$P_r(X_1\oplus X_3=0)=P_r((X_1\oplus X_2)\oplus (X_2\oplus X_3)=0)=1/2+2\varepsilon_{1,2}\varepsilon_{2,3}$，所以可以通过连接多个线性表达式形成新的线性表达式。
  所以可以通过列出所有 小型线性表达式 的 线性概率偏移量表，来计算出大的线性表达式的值。



###### 线性近似偏离量表

对于一个给定的S盒，总能生成一张表，纵表头为input的十六进制，横表头为output的十六进制。对于一个S盒，有16种不同的4比特输入-输出对。$a[i][j]$表示输入为i，输出为j时的<输入-输出>对数-8.

- 表中的值x除以16就是线性概率偏移量epsilon，由于$p=1/2+\varepsilon$，所以$1/2+x/16$就是线性表达式成立的概率
- 比如说线性近似偏离量表中，第3行第9列的值为-6，表示线性表达式$X_3\oplus X_4=Y_1\oplus Y_4$（写成二进制是0011和1001，即3和9）的线性概率偏移量是$-6/16=-3/8$，表达式成立概率为$1/2+(-3/8)=1/8$

###### 构造线性表达式

![](pic/crypto/线性分析.png)

如果得到明文P和第四轮的输入U4之间的线性关系，就可以忽略掉加密算法中间过程，来破解最后一轮的子密钥。那么如何得到呢？（书P102）

- （1）密钥层：设明文为P，第1轮与输出进行异或的子密钥为K1，则有$U_1=P\oplus K_1$.对于具体的第j位，有$U_{1,j}=P_j\oplus K_{1,j}$<u>（本笔记中记为U1-{P,K1}，表示左边是U1，右边是P和K1的线性表达式）</u>
- （2）S盒层：对于第1轮的S盒，列出输出V1-输入U1间的一个线性表达式，查表可以得到成立的概率。
- （3）代入：将（1）中得到的U1-{P,K1}带入到（2）中S盒的线性表达式中，即可化为V1-{P,K1}表达式
- （4）过渡层（P盒层）：找出第一轮输出V1和第二轮输入U2的过渡关系，图中是$U_{2,6}=V_{1,6}\oplus K_{2,6}$
- 对于第2轮，同第一轮的（2）列出V2-U2的表达式，从而得到V2-{V1,K2}，从而得到V2-{P,K1,K2}表达式
- 同理，得到V3-{P,K1,K2,K3}。之后根据V3和U4的关系，得到U4-{P,K1,K2,K3,K4}。因为$\sum k$是确定值0或1，所以可以得到U4-P线性表达式及其偏移量。
- 如果该表达式**偏移量足够大**，则说明该表达式很有用来验证P和U4是否匹配的价值，那么恢复最后一轮的子密钥来攻击该密码算法是可行的。如果找到一个K5，根据密文反求出的U4使得**满足该线性表达式的概率很大或很小**，那就说明U4确实和P匹配，那么K5是正确的子密钥

###### 猜测K5过程

```
产生n>=10000个明文密文对
字典遍历密钥K5
for K5 in 遍历的所有K5:
	计数器cnt=0
	for P,C in n个明文密文对:
		密文C和K5异或，反向通过S-4盒，求出该密钥对应的U4
		如果U4-P表达式成立，那么cnt+=1
	if cnt和n/2的差距最多:
		当前的K5是正确的子密钥
```



##### 3.差分密码分析

###### 差分和差分特征

差分：设加密算法的两次输入为X'和X''，对应的输出为Y'和Y''，则输入差分$\Delta X=X'\oplus X''$，输出差分$\Delta Y = Y' \oplus Y''$，$(\Delta X,\Delta Y)$称为一个差分对。

设输入输出均为n位，理想随机化加密时，对于给定$\Delta X$，特定的$\Delta Y$出现的概率为$1/2^n$，如果实际中概率远大于它，则可以被差分分析利用

差分特征：特定的输入差分和输出差分构成差分特征。如果一个差分特征概率很大（对应线性分析中的线性表达式），那么就有可能用来猜测密钥。和线性分析类似，如果找到一个由明文差分和最后一轮输入差分组成的高概率差分对，就可以利用输入P到U4的信息来猜测K5。获得高概率的差分特征需要观察S盒的性质

对于一个给定的4x4的S盒，可以计算出所有差分对出现的概率，生成16x16的**输入输出差分分布表**，$A[i][j]$表示输入差分为i，输出差分为j时的出现次数。例如$A[B][2]=8$，表明输出差分为2时，任取两个输入，它们差分为B的概率是8/16（注意这里是由输出差分△V反推输入差分△U）

密钥不影响S盒的差分分布

###### 构造差分特征

- （1）首先一个S盒的输入输出差分对△U1-△V1，查表得到成立的概率（选取依据是这些概率尽可能大）
- （2）△P(△U1)-△V1-△U2-△V2-△U3-△V3-△U4，计算相邻两项对应的概率，其中△Vi和△Ui+1之间是P盒不用计算概率，而△Ui-△Vi之间按概率成立，需要查表。三轮的概率相乘后，能得到△P-△U4的概率，如果这个概率很大，则称这样的差分特征△P-△U4为正确对

---

### 第七章 Hash函数

#### 哈希函数的性质

- 压缩性：Hash 函数将一个任意比特长度的输入 x 映射为固定长度为 n 的输出 H(x)
- 正向计算简单性
- 逆向计算困难性：反向找到消息在计算上不可行
- 弱无碰撞性：指定一个输入x，找x'使得哈希值相同，在计算上不可行
- 强无碰撞性：任意找一对输入哈希值相同，在计算上不可行

生日悖论问题：强无碰撞性下，23人碰撞率超过1/2

迭代哈希函数：将输入分成多组，重复使用压缩函数f，上一组的输出和本组输入作为参数

MD5：使用4个缓冲寄存器，每个32位。进行4轮迭代，每轮16步循环左移

SHA（安全Hash算法）：SHA-1每组512位

哈希用于认证



#### 消息认证码MAC

消息认证码MAC：一个双方共享的密钥k和消息m作为输入的函数，认证标记$\delta=MAC_k(m)$，用于保证数据完整性。如果攻击者找到一个(m,delta)对就攻破成功了。MAC与数字签名的不同之处是**MAC使用对称密码**，双方拥有预先的密钥

基于分组密码的MAC

基于带密钥哈希函数的MAC：HMAC

穷举攻击：多个密钥产生同一个MAC，穷举密钥；对于异或形式的MAC，可以伪造同delta的输入消息

------

### 第八章 公钥密码

单向陷门函数：单向性，有私钥才能反解

#### RSA

- 大素数乘积n=pq，1024bit，$\varphi(n)=(p-1)(q-1)$
- 选择一个整数e，满足$1\lt e\lt \varphi(n)$，使得$\gcd(e,\varphi(n))=1$（常用的e是65537）
- $de \mod \varphi(n)=1$，d是e在模$\varphi(n)$下的乘法逆元（使用扩展欧几里得来求d）
- {e,n}为公钥，{d,n}为私钥
- 加密：C=M^e mod n。如果明文是字母，则先数字化，然后分块加密
- 解密：M=C^d mod n

加密和解密都需要使用快速幂取模来加速计算

快速幂：减少乘法次数，先把指数写成二进制。例如指数13->1101，所以只需计算$a,a^2,a^4,a^8$，其中每项是前一项的平方，再根据对应的二进制位来抉择是否要乘上该项就可以了，时间复杂度从O(n)降为O(logn)
$$
a^{13}=a^{8+4+1}
$$

当需要快速幂取模时，每一步乘法都要取模

```python
def fastExp(a, n, mod):
    tmp = a
    ans = 1
    while n:
        # 当前位为1，需要该项乘进来
        if n & 1:
            ans = (ans * tmp) % mod
        tmp = (tmp * tmp) % mod
        n >>= 1
    return ans
```



#### 对RSA的攻击

目标是分解模数n

公共模数攻击：利用幂剩余变换的周期性。不断对c进行加密$c_1=c^e \mod n$，经过k+1次迭代后，结果正好回到密文c，那么第k步的变换结果$c_k$就是明文m，因为再加密一次就是密文了。周期k与phi(p)和phi(q)的最小公倍数有关，要想使得k尽量大，就要让p和q尽量大，这样最小公倍数也就大

选择密文攻击

低加密指数攻击

#### RSA-OAEP加密标准

最佳非对称加密填充OAEP：对消息编码的方法

#### ElGamal密码体制

ElGamal算法基于离散对数的难解性，即已知y,g,p求有限域上的离散对数$x=\log_gy$很难

- 密钥产生：选择素数p，小于p的随机数g和x，计算$y=g^x \mod p$
- $(y,g,p)$为公钥，x为私钥
- 公钥加密：$C_1=g^k \mod p,C_2=y^kM \mod p$，密文$C=(C_1,C_2)$

- 私钥解密：$M=C_2C_1^{-x} \mod p$

正确性证明：
$$
C_2C_1^{-x} \mod p=(y^kM)(g^k)^{-x} \mod p\\
=(g^{kx}M)(g^k)^{-x} \mod p=M\mod p
$$


------

### 第九章 数字签名

数字签名的攻击

#### RSA签名

- 私钥签名：$s=H(M)^d\mod{n}$，然后将M和s发给接收方
- 验证$H(M)=s^e \mod n$，如果哈希值相同则通过

#### DSA签名

- 参数：p,q为素数，p,q,g公开，私钥为x，k为随机数
- 签名：对消息M签名，$r=(g^k \mod p)\mod q$，$s=(k^{-1}(SHA(M))+xr)\mod q$。
  如果r=0或s=0，需要重新产生k，并计算签名r和s
  发送(M||r||s)
- 验签：y为公钥，(s,r,p,q,g,M,y)=r

#### ElGamal签名

签名：

- 设p为大素数，a是模p的本原元，p和a公开。随机选取私钥x，公钥$y=\alpha^x \mod p$，
- 随机选择k，gcd(k,p-1)=1
- $r=\alpha^k \mod p$
- 设m为消息，$s=(m-xr)k^{-1} \pmod {p-1}$，即(m-xr)乘k模(p-1)的乘法逆元
- (r,s)为签名，将(m,r,s)发给对方

验签：验证$\alpha^m$和$y^rr^s$是否相等

证明：
$$
s=(m-xr)k^{-1} \pmod {p-1}\\
m=xr+ks \pmod {p-1}\\
\alpha^m=\alpha^{xr+ks}=y^rr^s
$$


### 第十章 安全协议

df密钥协商协议易受中间人攻击，使用证书来证明身份

NS协议：三次握手，协商共同密钥Nb

基于公钥密码身份认证：A发送随机数R，B私钥加密R发给A签名。随机数防止重放攻击

基于口令的认证：基于单向函数；掺杂随机字符串salt

#### 秘密共享

Shamir秘密共享：基于拉格朗日插值

- 初始化：分发$x_1,...,x_n$给n个人

- 秘密分发：分发者D随机选取系数$a_1,...,a_{t-1}$，构造t-1次多项式（注意要模一个素数p），然后将yi分发给n个人
  $$
  f(x)=(s+a_1x+a_2x^2...+a_{t-1}x^{t-1})\mod p
  $$

- 秘密恢复：n个人里任意t个人用自己的坐标(xi,yi)重构多项式和秘密（x=0）

注意：**公式中的分母要求模p的乘法逆元**，比如分母相乘后为8，那么就相当于乘8模p的乘法逆元，用扩展欧几里得来求
$$
f(x)=\sum_{i=1}^{t}[y_i\prod_{j=1,i\ne j}^t\frac{x-x_j}{x_i-x_j}](mod\ p)\\
s=a_0=\sum_{i=1}^{t}[y_i\prod_{j=1,i\ne j}^t\frac{x_j}{x_j-x_i}](mod\ p)\
$$

最后得到的表达式中每个系数都要模p

例如：在一个(3,5)的 Shamir 秘密共享方案中，用模数 *p*=17 将(1,8),(3,10),(5,11)分别给 Alice，Bob 和 Cherry。计算一下相应的拉格朗日插值多项式，并确定秘密。

$$
f(x)=\sum_{i=1}^{t}[y_i\prod_{j=1,i\ne j}^t\frac{x-x_j}{x_i-x_j}](mod\ 17)\\
=8\frac{x-3}{1-3}\frac{x-5}{1-5}(mod\ 17)+10\frac{x-1}{3-1}\frac{x-5}{3-5}(mod\ 17)+11\frac{x-1}{5-1}\frac{x-3}{5-3}(mod\ 17)\\
=8(x-3)(x-5)(8^{-1}mod\ 17)+10(x-1)(x-5)((-4)^{-1}mod\ 17)+11(x-1)(x-3)(8^{-1}mod\ 17)\\
=[8(x-3)(x-5)15+10(x-1)(x-5)4+11(x-1)(x-3)15](mod\ 17)\\
=2495 - 1860 x + 325x^2(mod\ 17)\\
=13-7x+2x^2
$$

秘密为13。可以将坐标带入f中，模17验证答案



#### 比特承诺

A向B承诺一个消息m，过一段时间后，A能向B证实承诺的消息，并且保证这段时间内m没被篡改。（例如用于石头剪子布的同步）

一种方法是：

- A需要承诺m，随机选择r1，将H=Hash(r1,m)发给B。（随机数的作用是避免B建立了{m,hash(m)}的字典，可以反推回m）
- 当A需要证实自己承诺过m时，将m和r1发给B
- B来验证H'=H

性质

- 隐蔽性：接收者不能通过接受的加密消息来确定承诺值
- 约束性：发送者能打开加密消息，但发送者打开后得到的承诺值只能是原来承诺的数值

使用对称密码，使用单向函数的比特承诺

零知识证明：任何NP语言都存在一个零知识证明

- 零知识洞穴问题，需要引入随机数，每次P成功欺骗V的概率是1/2，多次欺骗成功的概率很小。
- 色盲：如果每次都能选对，就能证明存在颜色不同
- 图同构

区块链

Merkle树：管理一个区块里的所有交易

### 复习

题型：简答，计算，证明

- 完善保密，凯撒
- 信息论，分布公式
- 欧几里得求gcd，扩展欧几里得求逆；表示有限域的元素，多项式模运算，多项式乘法逆
- 序列密码，特征多项式，画出来LFSR，生成序列。BM算法
- 分组密码：AES有限域运算，DES，线性分析，差分分析，堆积，求偏移量
- 哈希：安全性、抗强弱碰撞，生日攻击，md5，sha，mac设计，cbcmac
- 公钥密码：RSA，离散对数elgamal
- 签名：DSA，elgamal，最优填充
- 安全协议：认证，密钥交换，安全性

