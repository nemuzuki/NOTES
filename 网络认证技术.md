课件地址：sep-课程网站-我的课程-网络认证技术-资源

课程主要内容：密码学、认证协议、pki、数字证书、认证系统方案

### 第一章 导言

网络认证：网络环境中如何确认身份；网络认证的目标：在不可信的网络环境中确认一个主机的身份、属性、权限，抵抗可能带来的攻击。

网络认证技术包括

- 认证（Certification）：获取身份的过程（发身份证，证书certificate）；
- 鉴别（Authentication）：验证身份的过程（网站登录口令）

基于口令（password）鉴别的问题：

- 重放攻击：攻击者发送一个目的主机已接收过的包
- 穷举暴力攻击
- 维护数据库
- 容易被中间人截获，需要密码算法（cryptography）

对称加密：加密密钥=解密密钥。一种最naive的对称加密实现口令鉴别：服务器生成一个随机数nonce，用该用户的passwd作为密钥加密发给用户，如果用户能用自己的passwd解密出nonce即鉴别成功
缺点是难以协商密钥，分发和管理大规模密钥

<img src="pic/authen/对称加密.png" style="zoom: 50%;" />

非对称加密：明文通过公钥加密，通过私钥解密。

PKI（Public Key Infrastructure）：公钥基础设施，以非对称密码为基础的，提供安全交易服务的网络应用的基础设施，遵循规定的密钥管理平台。
PKI的核心是认证机构CA，CA颁发数字证书（certification过程），数字证书将用户的公钥和用户属性信息组合在一起，然后进行数字签名，内容不可篡改，可由CA的公钥公开验证（authentication过程）

<img src="pic/authen/数字证书原理.png" style="zoom:60%;" />

SSO单点登录：用户只需一次登录就可以访问所有相互信任的应用系统

### 第二章 密码学基础

不同的明文plain text一定映射到不同的密文cipher text

攻击类型

- 唯密文攻击：只有多个用同一密钥加密的密文
- 已知明文攻击：有一些明文和对应密文
- 选择明文攻击：可以得到任何明文对应的密文
- 选择密文攻击：可以得到任何密文对应的明文

唯密钥保密：假设只有密钥未知，加密算法已知，攻击者没有无限资源

现代密码算法种类：分组密码：将明文分成多块单独加密；流密码：对每个字节加密，当前字节的加密结果和之前的计算有关

对称密码算法

- DES：输入输出均为64bit，密钥56bit；三重DES：密钥112bit；AES：分组长度128bit；消息鉴别码MAC
- 优点：空间小，速度快
- 缺点：需要事先共享密钥，无法生成数字签名，n个人需要n(n-1)个密钥

非对称密码算法

- 加解密模型：公钥加密，私钥解密
- 数字签名模型：私钥生成数字签名，公钥验证
- 优点：不需事先共享密钥，和多个人通信可用相同公钥
- 缺点：速度慢，未必比对称密码安全，各有各的用途
- RSA
  ECDSA：是ECC（椭圆曲线密码编码学）与DSA的结合，密钥比RSA短，计算量小

单向 陷门 函数：

- 单向：已知公钥和消息，正向计算密文容易；不知私钥时，反向计算不可行
- 陷门：知道私钥时，反向计算容易

Hash算法

- 输出定长
- MD5 SHA256 SM3

密码算法应用

（1）数字签名：私钥加密m，公钥解密与m对照验签

#### （2）Diffie-Hellman密钥交换

非对称，基于离散对数难解性问题，保证两个用户安全交换密钥。
离散对数难解性问题：若$b=g^x \mod p$，称x为b的以g为底的离散对数，已知b,g,p求x是困难的

- 两人共享g
- Alice产生**随机数**xa，计算$y_a=g^{x_a} \mod p$，将ya发给Bob；
- Bob产生随机数xb，计算$y_b=g^{x_b} \mod p$，将yb发给Alice；
- 密钥$K=y_b^{x_a} \mod p=y_a^{x_b} \mod p=g^{x_ax_b}\mod p$
- 攻击者知道p, g, ya, yb，无法求xa, xb, K

（3）消息鉴别码MAC：验证数据完整性，是有密钥参与的hash（先hash再加密）

可鉴别加密：一个计算同时保证完整性和机密性

作业：使用Open Source密码软件库，熟悉各种密码算法的使用

- 对称：AES
- 非对称：RSA
- hash：md5

#### Ubuntu下C++编译botan

[Botan: Crypto and TLS for Modern C++ — Botan (randombit.net)](https://botan.randombit.net/)下载Botan-2.19.2.tar.xz

```sh
python configure.py
sudo make install
sudo ldconfig	# 搜索共享库文件
```

编写botan程序

```cpp
#include<botan/botan.h>
```

编译

```sh
g++ -o test test.cpp -std=c++11 -I/usr/local/include/botan-2 -Wno-cpp -Wno-deprecated-declarations -lbotan-2
./test
```

md5

```cpp
#include <iostream>
#include <string>
#include <cstdio>
#include <botan/botan.h>

using namespace std;
using namespace Botan;
void md5(string input){
    HashFunction *hash = get_hash("MD5");//choose a hash func
    secure_vector<uint8_t> result = hash->process(input);
    for(int i=0;i<result.size();++i){
        printf("%02x",result[i]);//add 0 before hex
    }
}
```

[Public Key Cryptography — Botan (randombit.net)](https://botan.randombit.net/handbook/api_ref/pubkey.html)介绍了函数的使用

------

### 第三章 基于口令的鉴别

基于口令的身份鉴别：双方都已知口令，需要利用口令来相互确认身份

常见攻击：被动攻击只监听，主动攻击要插入

- 字典攻击：尝试的口令有一定范围（弱口令），尝试攻击许多人，能成就成

- **重放攻击**：攻击者监听，模仿之前窃听到的正常会话，冒用身份

- 中间人攻击：攻击者在中间分别给双方传话，并提供自己的公钥给双方


LGSN口令鉴别方案：用户用server的公钥加密口令发给服务器，仍容易穷举口令，再用公钥加密去试

#### EKE（encrypted key exchange，加密密钥交换协议）

EKE使得无法通过遍历口令来确认真正的口令。加密随机数而不是口令，因为随机数穷举的计算量太大。并且**随机数可以避免重放攻击**

- 双方共享口令p。
- A随机生成临时公私钥对，<u>用口令p加密公钥Ea发给B</u>
- B用口令p解密出公钥Ea，生成随机数R，将P(Ea(R))发给A。**（此时完成了密钥交换，R相当于之后的会话密钥）**
- A生成随机数cha，发R(cha)给B
- B用R解密cha，并产生随机数chb，R(cha||chb)给A
- A验证cha，并将R(chb)发给B
- B验证chb**（此时完成了双向认证，证明了双方都有会话密钥R）**

也就是说一个用户用自己的随机数ch和会话密钥R这两个要素才能认证对方也有R

![](pic/authen/EKE.png)

EKE相当于一个框架，第二步是【用口令p加密公钥Ea发给B】，加密方法很多，包括RSA和基于dh等，下面介绍基于dh的EKE



#### DH-EKE：基于DH密钥交换协议的EKE

- 首先使用dh密钥交换使得双方得到会话对称密钥$K=g^{x_ax_b} \mod p$
- B生成随机数Nb，将K(Nb)发给A
- A解密出Nb，生成随机数Na，K(Na,Nb)发给B
- B验证Nb，K通过。将K(Na)发给A
- A验证Na，K通过。（双向认证了双方算出的K是相同的）

EKE和DH-EKE的局限性：通信双方共享的是口令的原文，可能会被泄露。



#### verifier-based协议

不直接存储口令，口令经过变换后存储在服务器上

口令经过单向计算得到verifier，相同口令在不同服务器上verifier不同

A-EKE（Augmented EKE，加强EKE）：是一个verifier-based协议，用单向函数H(p)来替代口令p来加密随机数。但是敌手可以获得大量H(p)，再通过一次穷举p可以攻破大量p。所以用(salt, H(p, salt))来存储口令，一次穷举只能攻破一个口令p

B-SPEKE：两次dh，一次交换密钥，第二次验证客户端口令p正确；使用Hash传输，不传明文



#### SRP协议

SRP（The Secure Remote Password Protocol，安全远程密码协议）。SRP是一个零知识协议，即鉴别通信过程中，不发送与口令有关的信息给服务器，但是服务器可以知道用户有口令。

![](pic/authen/SRP.png)

假设客户端拥有口令x1，服务端有口令x2，双方都有对方口令经过单向变换P后的结果，并且分别生成随机数r1, r2

- 客户端向服务端发送$P(r_1)$，服务端向客户端发送$P(r_2)$
- 客户端拥有$x_1,r_1,P(x_2),P(r_2)$，服务端拥有$x_2,r_2,P(x_1),P(r_1)$
- 客户端计算$K = S(R(P(r_2), P(x_2)), Q(r_1, x_1))$
- 服务端计算$K = S(R(P(r_1), P(x_1)), Q(r_2, x_2))$
- 之后会利用双向哈希函数H进行双方会话密钥K的校验M1和M2

函数定义：
$$
P(x)=g^x，Q(r,x)=r+ux ， R(r,x)=rx^u， S(r,x)=r^x\\
K=g^{(r_1+ux_1)(r_2+ux_2)}
$$
可以看到，双方的鉴别过程只是交换了随机数的变换，并未交换口令或者口令的变换

实际上，服务端要给客户端发送的不是$P(r_2)=g^{r_2}$，而是$B=g^{x_1}+g^{r_2}$，Client得到B之后，减去$g^{x_1}$、即可得到P(r2)。假设直接使用P(r2)，那么攻击者可以假冒服务器发送P(r2)，在计算K的时候穷举x1，直到验证文本和已经掌握的正确的M1成立，即可破解x1。

虽然使用$B=g^{x_1}+g^{r_2}$时又引入了口令信息，但是攻击者无法伪装成服务器来实现穷举攻击，因为$B=g^{x_1}+g^{r_2}$是一个整体，攻击者不知道$g^{x_1}$，如果随便发送一个B的话r2也不知道，就有两个未知量了，后续基本不可能验证M1。

------

### 第四章 基于共享秘密的鉴别

基于共享秘密的实体鉴别是基于**对称密码**算法的鉴别。共享秘密$K_{AB}$指的是长秘密信息，不像口令能被穷举。实体：需要鉴别的对象，比如设备、软件。

传统鉴别方案1：B用k加密随机数N发给A，A用k解开N发给B，完成了B对A的鉴别，设双方都可以进行解密，即可双方鉴别。攻击者I随便发一个数（作为密文E(N1））给B，B仍可以用k解开（只是解出来的没有意义），并发送E(n2)给I；I将E(n2)发给A，A解密出n2发回I；I将n2发给B，这样I就冒充A完成了B对它的身份鉴别

并行会话攻击（Parallel Session）：中间人会使用多个线程来和A交互，在一个会话中使用前一个会话得到的数据，从而完成身份鉴别，冒充B。预防：需要在数据中包含发送人的信息

身份鉴别的要求：1.确认身份 2.确认背后是本人在参与鉴别过程，防止重放、中间人攻击

TN：时间戳

单向鉴别

- 一次通信
- 两次通信

双向鉴别：两个单向鉴别

Woo-Lam协议：借助可信第三方来实现双方密钥共享

------

### 第五章  基于数字签名的鉴别

基于数字签名的实体鉴别是基于非对称密码算法的鉴别

传统鉴别方案：A发送一个随机数n给B，B用私钥加密n给A，A用B的公钥解密出n，和之前对比正确则鉴别成功

中间人攻击：中间人直接转发A的随机数n和B对n的签名，可以冒充B的身份，即B身份鉴别的背后并不是B完成的。

实体鉴别的目标是：B向A证明自己的身份时，A必须知道：B知道自己正在向A证明

单向鉴别：

- 一次通信
- 两次通信

双向鉴别：两个单向鉴别

------

### 第六章 PKI系统基本结构

CA（Certification Authority）是PKI的核心。两个工作：签发证书（生成证书），发布证书（告知其他人）。

安全需求：

- 真实性：数据源鉴别，的确来自CA
- 完整性：发布的信息没有被篡改
- 非否认：CA发布之后，不能否认

PKI系统工作流程：

- 初始化：CA产生自己的公私钥对、自签名证书
- 订户产生公私密钥对
- 将自己的公钥和身份信息交给CA
- CA签发订户证书交给订户，并自己留有备份
- CA随时响应用户的证书查询

订户（Subscriber）：拥有公私密钥对和相应证书的通信方

用户（User）：享受PKI服务的实体，包括订户和查证书的人

#### 证书格式

证书包括三部分：

- 证书内容：版本，序列号，主体，**主体的公钥**，签发者（CA名称），有效期，辅助信息
- CA的签名算法
- CA对证书内容的签名结果

在X.509证书中，CA名称使用X.500 DN（可识别名）来标识

如何验证证书的有效性：用CA的公钥来解密CA对证书内容的签名结果，与证书内容相比较，如果相同则证明证书是CA签发的。

为什么黑客不能盗用server的证书发给用户来冒充身份：因为用户会用server的公钥来给server发送加密的信息，黑客没有私钥无法解密，即使冒充了也没有用

#### 证书签发

RA（注册机构）：为避免CA与大量用户直接接触，工作过于繁重，签发证书之前，RA先验证申请证书的订户的身份信息的正确性，再让CA签发证书。RA也有自己的CA数字证书。

申请证书时流程：订户公钥->RA->CA；签发证书时：CA->订户

CA分层：在世界各地建立子CA，根CA给子CA签发证书，每个子CA维护自己的系统和用户，之后根CA和子CA就很少通信了

#### 证书发布

资料库Repository：PKI系统拥有资料库，用于存储所有的证书实现证书分发（因为CA下线就不能发了），需要为所有PKI用户提供api服务

#### 证书撤销

RA接受撤销申请，审核通过后告知CA

证书撤销列表CRL：包含被撤销证书的序列号，CA对CRL进行签名。为避免CA负担，CRL Issuer专门负责签发CRL。CRL定期发布，每次发布一批被撤销的证书信息

用户拿到证书时，先验证：证书是否在有效期内；证书签名是否有效；是否在CRL中

在线证书状态协议OCSP：用于检查证书是否已经被撤销，OCSP服务器专门响应是否撤销

------

### 第七章 PKI证书编码

#### ASN.1语言

ASN.1是一种描述数据结构的语言（并没有值），用于数据序列化。订户使用证书注册API时，使用ASN.1语法来编码和解码证书请求和证书

ASN.1通过简单数据类型构造出复杂类型

例如下面是证书格式的结构体，包括证书内容，签名算法，内容的签名

```ASN.1
Certificate  ::=  SEQUENCE  {
      tbsCertificate		TBSCertificate,
      signatureAlgorithm  	AlgorithmIdentifier,
      signatureValue       	BIT STRING
}
```

TBSCertificate包含了用户想要的证书信息，结构体为：

![](pic/authen/证书asn.1.png)

#### 关键字

SEQUENCE：组合类型，表示由若干数据项有序排列

CHOICE：表示可以是{}中的任意一项

OPTIONAL表示该项可以不存在。如果同类型多个变量可选，需要添加标签[i]来区分

```ASN.1
Image ::= SEQUENCE { 
    Width  INTEGER OPTIONAL,
    Height INTEGER OPTIONAL,
    Title  UTF8String
 }
收到数据：INTEGER(750), UTF8String("A funny kitten")将不知道750是宽度还是高度
```

加入隐式标签[i] IMPLICIT，不写IMPLICIT时默认使用隐式标签，数据中无需类型，节省空间。`80 02 33 77`：80表示隐式标签类型，02表示长度为2，33 77为value

```asn.1
Image ::= SEQUENCE { 
    Width  [0] IMPLICIT INTEGER OPTIONAL,
    Height [1] IMPLICIT INTEGER OPTIONAL,
    Title  UTF8String
 }
 隐式标签数据：[1](750), UTF8String("A funny kitten")，可以知道750指的是高度
 显式标签数据：[1]INTEGER(750), UTF8String("A funny kitten")
```

显式标签在类型前面加上[i] EXPLICIT，使得数据在原本的[t,l,v]编码前面再来一层[t,l]，当类型Version结构体里面仍然可选元素时使用

```asn.1
version		[0]	EXPLICIT Version DEFAULT v1
```



#### DER编码

ASN.1的**值的传送**可使用DER（可辨别编码规则）来编码成二进制

每个编码由【类型type，长度length，值value】组成。例如TRUE的编码为`01 01 ff`，代表【bool类型，1字节，True】
BOOLEAN=01, INTEGER=02

长度编码机制：如何区分长度字段和值字段的分界，采用扩展，用一个字段表示“长度”的字节数

OID（Object Identifier）：一种编码，作为DER的value部分。多个非负整数之间用点分隔，可以表示任何事物，如1.2.840.113549.1.1代表了RSA公司的标准PKCS#1

------

### 第八章 证书扩展

如果想在证书中带有更多信息，就需要证书扩展，位于证书内容的最后。X.509定义了16种标准证书扩展，使用OID来标识16种不同的扩展名称。Critical表示关键扩展，必须验证

1.Basic Constraints：用于区分是否为CA证书，以及路径的深度

是否为CA证书：CA证书和订户证书需要区分，否则订户也能给别人签发证书，这种证书要被拒绝

路径深度：CA证书与最终订户证书之间，最多可以有的证书数目。为了限制子CA的权力，路径过长，信任可能有问题（朋友的朋友的朋友的朋友的朋友的朋友的朋友有可能是敌人）

```asn.1
id-ce-basicConstraints OBJECT IDENTIFIER::={id-ce 19}
BasicConstraints ::= SEQUENCE {
	CA BOOLEAN DEFAULT FALSE,
	pathLenConstraint INTEGER (0..MAX) OPTIONAL
}
```

2.Authority Key Identifier：CA具有多个密钥-证书对，需要CA密钥标识具体是哪个证书。使用签发者Issuer+证书序列号，或者公钥信息的HASH结果作为标识

3.Subject Key Identifier：订户有多个密钥-证书对，需要确定具体是订户的哪个证书。使用订户公钥的hash结果作为标识

4.密钥用途Key Usage：定义了密钥的9种用途，共9bit，如用于加密、数字签名、不可抵赖、密钥交换、CRL签名等

5.私钥使用期限Private Key Usage Period：私钥使用寿命，开始时间和结束时间

6.CA的名称信息Issuer Alternative Name：签发者的别名

7.订户名称信息Subject Alternative Name：订户的别名

8.订户其他信息Subject Directory Attributes

9.命名限制（Name Constraints）：限制CA给一定名字空间内的订户签发证书，例如保证北京CA只能给北京订户签发证书。使用树形结构，只要证书中订户的名称不在子树中，就认为证书无效

10.证书策略CP（Certificate Policies）：证书的安全等级，OID形式表示。例如CA证书使用5个CP——ABCDE，表示CA可以签发包含这5种CP的订户证书
任意策略（Any-Policy）：一种CP，表示什么都能干

11.Inhibit Any-Policy：值是整数N，表示在证书路径中，本证书之下的N个证书可带有Any-Policy的证书，N+1之下的证书就不能有Any-Policy。保证了CA的行为可控

12.策略映射（Policy Mappings）：用于**交叉认证**，建立不同CA的不同安全等级CP之间的映射（ABC->甲乙丙）

13.Policy Constraints：不应该支持无限制的策略映射，因为多次映射后两种CP可能完全不相等

14.扩展密钥用途Extended Key Usage：相比KeyUsage更细致了，如Key Usage、电子邮件的加解密、签名

15.CRL Distribution Points：检查当前证书需要的CRL的位置

16.Freshest CRL：用在增量CRL情况下，获取最新的增量CRL的地址

------

### 第九章 PKI系统信任体系

#### 证书申请过程的可信绑定

证书申请时，订户自己生成公私钥对，将公钥发给CA。但传输公钥时可能出现问题，如传输错误，公钥被中间人替换等。为了保证公钥正确，需要**订户证明有公钥对应的私钥**，称为私钥的私有证明POP（Proof of Possession of Private Key）。

POP的三种方式：

- 签名密钥：要求订户用私钥**对证书请求消息签名**，CA即可用公钥验证。PKCS#10：一种证书请求的数据格式
- 加密密钥：直接方式：CA用订户未被证实的公钥加密信息，要求订户用私钥解密；间接方式：管理机构生成订户公私钥，CA用公钥加密证书发给订户
- 密钥协商密钥：CA使用证书请求中的公钥，与订户协商Session Key，然后进行通信，也就验证了订户是否有私钥。该方法要求CA与申请者同时在线通信

#### 根CA引入

使用证书链进行信任传递，方向是从终端到根

信任锚：信任的起点，如根CA

信任模型：对于PKI系统中的用户(验证证书的人)，应该具有什么样的信任锚，以及在信任传递过程中的各种措施

- 单根CA
- 多根CA

证书信任列表CTL：一个文件，用户自主/权威机构决定用哪些信任锚

鉴定CA（ACA）：给其他根CA签发鉴定证书，改变了信任锚

#### PKI系统互认

交叉认证：不同域的CA之间签发证书，使得订户可以不用远距离认证。最大优点：与CTL不同，没有改变信任锚，可以随时撤销

如果交叉认证形成网状，可能策略映射结果不同

桥CA（BCA）与每个CA进行双向交叉认证，从而能够连通所有的CA。如果不想让所有CA之间都相互认证，可以使用命名限制来控制，如在CA1给BCA的交叉证书中的命名限制扩展中写明BCA只能给CA3、CA4签发证书

混合模式信任模型

------

### 第十章 证书撤销

需要撤销证书的场景：订户发现私钥泄露、证书过期、证书付费到期、CA失信等

撤销过程：

- 用户向RA提出撤销请求
- RA审查撤销请求，若通过则将撤销请求发给CA或CRL签发者
- CA或CRL签发者签发CRL，修改证书状态

证书撤销方法：CRL、OCSP、CRT（后两者依赖于CRL）、短周期证书

#### 证书撤销列表CRL

证书撤销列表CRL（Certificate Revocation List）由CA定期签发，CRL是一个数字文件，后缀`.crl`。证书中包含CRL分发点CDP（CRL Distribution Point）：下载crl的位置

CRL格式和证书很类似

- CRL内容：
  - 版本，签发者Issuer，CRL签发时间，失效时间（下次签发时间）
  - 每个被撤销证书的序列号、撤销时间。crlEntry扩展：对于每个被撤销的证书需要给出其他信息，如撤销原因、证书出问题的时间、如果CRL里有不同签发者签发的证书，序列号不能唯一标明证书，需要在entry扩展里面标明签发者
  - CRL扩展：类似证书扩展
- 签发者对CRL的签名算法
- 签发者对CRL的签名值

CRL类型

- 完全CRL：一个CA签发的 所有证书 の撤销状态，存在一个CRL文件里面，文件巨大

- 增量CRL：相对于某次完全CRL的撤销列表的变化量，即完全CRL的一部分，如一周内被撤销的证书信息

- 直接CRL：证书的签发者就是CRL的签发者，即CA签发的CRL。给CA负担较大

- 间接CRL：专门的CRL Issuer机构签发的CRL。CRL Issuer需要CA认证


CRL分发点CDP（CRL Distribution Point）：CRL的访问地址，是一个URL。CRL可拆分成多个小文件，按照序列号或者撤销原因分组



特殊形式的CRL：

- 特殊拆分的CRL文件：假设有三张证书被撤销，序列号为r1,r2,r3，生成n-1个CRL，sign(r1,r2),sign(r2,r3)，以及两个特殊序号的CRL Sign(负无穷, R1)和Sign(R3, 正无穷)
- 重定向CRL：因为给定证书难以确定对应的CRL文件，所以引入RCRL。类似二级页表，先查CDP信息表（RCRL文件）获得【证书范围，范围对应的CRL地址】，再访问CRL

#### 在线证书状态协议OCSP

为了避免保存CRL文件，并且减少签发者对CRL的签发负担，所以引入OCSP

OCSP的基本流程

- 用户直接向OCSP服务器发出查询请求TBSRequest证书是否被撤销
- 服务器响应OCSP Response是/否/不知道

OCSP来源为最新的CRL或者内部数据库

OCSP服务器需要对每个响应进行签名，开销较大

#### 证书撤销树CRT

服务器只需一次签名

服务器将被撤销证书按序号排序，按二叉树形式两两hash，最后**服务器对根签名**。类似merkle tree

- 服务器将验证路径上需要的叶节点信息、hash值以及根的签名响应给用户
- 用户根据这些信息算出根hash，进行签名的验证

<img src="pic/authen/CRT.png" style="zoom: 33%;" />

例如查询670，服务器需要将相邻子树的叶节点以及路径上需要的哈希值发给用户，用户可以得知670没被撤销

#### 短周期证书

将证书的周期设定为与CRL的更新期一致，就不再需要CRL。但是CA需要每天不断地发证，并且存在除过期外导致的撤销问题

------

### 第十一章 TLS协议

TLS（Transport Layer Security）基于TCP和PKI技术提供机密性、完整性、身份鉴别，HTTPS（http over TLS）是最知名的使用数字证书的协议。有两层

<img src="pic/authen/TLS报文.png" style="zoom: 67%;" />

- 下层为Record：记录当前密码算法状态，包括密钥，MAC，由Handshake协商得到的各种密码运算参数
- 上层4种数据，四选一：Handshake协商密钥，alert告警，Change Cipher Spec告知接下来发送的消息要使用加密算法，Application Data应用数据

#### TLS1.2 Handshake 4次握手

<img src="pic/authen/TLS.png" style="zoom: 80%;" />

client和server协商对称加解密算法和密钥、HMAC算法和密钥、压缩/解压算法

最简单的Handshake过程：也是用非对称加密对称密钥，单向鉴别.在之前需要进行连接

- client hello：client向server发送多种密码算法套件供选择，并发送随机数
- server hello：server选定一种密码算法
  server certificate：server的**证书**链（一组证书序列，不包含根证书，因为根需要已经被client信任）。包含了server的公钥
  server hello done：完成身份鉴别
- client key exchange：**client产生预主密钥，并用server公钥加密**，发给server。此时双方用预主密钥产生各种所需密钥
  client change cipher spec：通知server下面要使用协商好的算法。client切换为写状态，server切换为读状态。（不属于handshake消息）
  client finished：第一条被加密的消息，验证协商的参数是一致的
- server change cipher spec：通知client开始使用协商好的算法
  server finished

如果server要鉴别client，会在发送自己证书之后发送certificate request；
client会在client key exchange前回应自己的证书链Certificate、用client私钥对之前所有handshake消息的签名Certificate Verify，来证明证书是自己的，而不是访问其他人的过程中获取的他人证书（而server就不需要提供CertificateVerify，因为要用server的公钥加密预主密钥，要是假的就没法解密；而client的公钥只能用于签名验证，不能用于加密，所以需要证明证书是自己的）

[TLS握手协议详解_chengqiuming的博客-CSDN博客_tls握手](https://blog.csdn.net/chengqiuming/article/details/83115642)

TLS支持会话重用：第一次在协商的过程中，ServerHello中给出Session ID；第二次在ClientHello中，设为上次的“Session ID”，表示想要重用

心脏滴血（Heartbleed）漏洞：

- 客户端向服务器发送心跳请求(Heatbeat_Request)消息，询问服务器是否在线，该消息中包含payload字段及其对应的payload_length字段；
- 服务器向客户端返回心跳响应(Heatbeat_Response)消息，服务器会根据请求消息中的payload_length将payload复制到响应消息中；服务器并不会检查 payload 的 实 际 长 度 是 否 与payload_length一致；如果payload_length比实际长度大，服务器仍然会按照payload_length返回数据，由此造成了内存信息的越界访问

TLS1.3：

- 身份鉴别支持使用预共享密钥PSK模式（非证书）；
- 减少了握手过程，直接在hello里面通过签名传递参数，hello之后全部加密，未加密的消息变少

------

### 第十二章 WiFi无线认证技术

WiFi鉴别方案√

- 基于共享口令的鉴别：所有人口令相同
- 基于用户身份的鉴别：有独立的账号，eduroam
- 专用客户端或网页鉴别：微信授权登录、短信，没有无线通信加密

WLAN参与方

- 访问接入点AP：无线接入点
- STA：工作站，即终端设备
- AS：鉴别服务器，特定情况使用

WEP（Wired Equivalent Privacy）：基于共享秘密

WPA（Wi-Fi Protected Access）：握手产生共享秘密
四次握手协商密钥：双方根据PMK计算，得到相同的PTK和GTK

- AP生成并向STA发送Anonce，STA生成Snonce，并计算PTK（成对密钥）
  $ PTK = PRF-X(PMK+Anonce+Snonce+AA+SPA)$
- STA向AP发送SNonce，并且计算MIC值后发送给AP
- 如果Message2中MIC校验成功，AP向STA发送是否安装PTK、用KEK加密的GTK、MIC
- STA验证MIC的正确性，正确则安装PTK和GTK，并发送确认包ACK给AP

------

### 第十三章 数字证书应用及实践

常见API

PKI API：公私密钥对管理，证书管理

CryptoAPI

CSP（Cryptographic Service Provider）：微软的加密应用接口，实现了CryptoAPI中的核心密码运算功能。操作系统通过调用CryptoAPI函数接口相应的加密服务提供者函数（CSP）

见作业3使用OpenSSL实现加密邮件和邮件签名

------

### 第十四章 PKI系统安全增强

PKI系统安全问题：CA不工作；或者未按安全策略提供服务

安全增强分为两个方向：入侵容忍的CA系统；信任增强的PKI体系

#### 1.入侵容忍的CA系统

入侵容忍：通过分布式CA使得CA被一定程度的入侵仍可以正常提供服务

秘密分享：使得n个人中任意f+1个人拼起来获得完整的私钥，f个人不可。提升机密性

- 访问结构（Access Structure）：设$L=C_n^f$组合数，将私钥d拆解为L个随机数（部分私钥）之和$d=d_1+...+ d_L$，对应L个子集，每个集合对应f个人的一种组合
  $$
  S_1=\{s_1,s_2,...,s_f\}\\
  S_2=\{s_2,s_3,...,s_{f+1}\}\\
  ...
  $$
  $d_k$分配给除了$S_k$中元素以外的所有人。这样随便来f个人，总能属于一个子集Sk，而他们都没有dk，再来一个人就有dk了，即可还原出d来

- 多项式曲线（Shamir）：得到f阶多项式
  $$
  f(x)=(s+a_1x+a_2x^2...+a_{f}x^{f})\mod p
  $$
  的f+1个点坐标，即可恢复出原多项式，多项式的常数项是私钥。拉格朗日插值公式恢复私钥
  $$
  f(x)=\sum_{i=1}^{f}[y_i\prod_{j=1,i\ne j}^f\frac{x-x_j}{x_i-x_j}](mod\ p)
  $$
  

ITTC系统：一种入侵容忍的CA系统

- 采用访问结构，并使用数字签名。设证书为M，每个服务器计算部分签名$M^{d_i}\mod{n}$，服务端将各服务器计算结果组合起来得到数字签名

$$
S=\prod_{i=1}^t M^{d_i}=M^{\sum_{i=1}^td_i}=M^d
$$

- 采用冗余配置：给每个服务器冗余配置多个部分私钥，即将d拆分成多种组合
  $d=d_1+d_2+d_3=d_4+d_5+d_6$

#### 2.信任增强的PKI体系

CA如果被攻击或控制（盗取了私钥），可能导致签发虚假证书，可能导致访问钓鱼网站。如何进行限制

HSTS（HTTP Strict Transport Security）：HTTP严格传输安全。告诉客户端浏览器只能通过 HTTPS 访问当前资源,而不是HTTP

安全增强的基本思路

- 客户端检测：在浏览器端实施检测，是否可能是虚假证书
- 限制CA权力：CA并不能任意地为任意TLS服务器签发证书
- 证书透明化：记录CA的证书签发行为，要求证书签发操作是透明的、公开的

##### 客户端检测

- Pinning：浏览器记录服务器证书信息，与后续访问比较
- Perspectives：建立第三方Notary公证服务器，周期性探测和存储各TLS服务器的公钥，client去Notary验证服务器公钥

##### 限制CA权力

- Certlock：比较新旧证书的CA是否来自同一个国家
- CAge：限制CA可以签发的顶级域名（TLD）
- DANE和CAA：
  - DANE（DNS-Based Authentication of Named Entities）使用DNSSEC体系存储**验证域名证书**或公钥的规则的方案，具体是在DNSSEC的一种特殊的资源记录TLSA Resource Record中，规定client验证域名证书时受信任CA的范围；
  - CAA（Certification Authority Authorization）允许域名使用DNSSEC体系声明被允许**签发域名证书**的CA的范围。当一个CA收到证书请求时，需要在DNS系统中检查是否有相应的CAA Resource Record存在
- Sovereign Key：TLS服务器具有额外的、自己生成的密钥对Sovereign Key，并登记到timeline服务器中。Client记录该域名的Sovereign Key，并在timeline server中检查更新。虚假证书生效，需要同时攻击CA、并获得Sovereign Key的私钥

##### 证书透明化

有一个公开的审计日志，所有签发的证书都记录在里面

------

### 第十五章 证书透明化方案

证书透明化：提供一个公开的系统，使得任何一个域名所有者或者CA可以观察、探测到虚假证书的存在

证书透明化方案（Certificate Transparency, CT）：将所有由CA签发证书记录在一个公开的日志(public log)中，位于公开日志服务器。日志只增不减，不会改

- 公开日志服务器（Public Log Server）：保存和维护记录证书的公开日志（Public Log）
- 监视员（Log Monitor）：周期性访问公开日志服务器，寻找和发现可疑的证书，保证服务器按规定发布数据
- 审计员（Auditor）：审计公开日志服务器的行为

一个证书确定会被日志收录时，公开日志服务器必须提供相应的记录凭据SCT（签名证书时间戳，signed certificate timestamp）给提交者（用户），方式有

- 证书扩展中包含SCT
- 预证书
- TLS扩展
- OCSP Stapling扩展

查询：Merkle Tree

透明化部署

Monitor：第三方监控，如Censys，返回证书

---

### 第十六章 隐式证书

#### 隐式证书

- 省去了CA对证书的签名
- 无法直接获取订户公钥，需要现算，订户公钥=中间公钥数据PU+CA公钥

证书申请

- 用户生成临时公私钥对，向CA请求证书；
- CA计算中间公钥PU，并生成证书；
- 用户计算出自己的最终公私钥

证书使用

- 先提取CA公钥
- 计算出订户公钥
- 再用订户公钥验证订户的消息签名（此时同时完成了对CA的验证）

优点：隐式证书大小、计算量比X.509小，适用于资源受限的物联网环境



#### 隐式证书典型应用：车联网V2X通信

SCMS（Security Credential Management System for V2V communications）：美国车联网的标准，利用实名证书申请批量的假名证书

PCA：颁发假名证书的CA

四种证书：

- OBE（车载设备）/RSE（路边设备）注册证书
- OBE假名证书：只证明合法用户，不证明是具体的谁
- 身份证书
- 应用证书

------

### 第十七章 Kerberos身份鉴别协议

Kerberos是一种基于**对称密码**，基于c/s模型的网络通信的鉴别协议，用来让服务器验证客户端是可信的

- 提供可信第三方鉴别服务（即作为client和server之间的桥梁）
- 支持单点登录SSO（用户只需输入一次身份验证信息就可以凭借此验证获得的票据(TGT)访问多个服务）
- 应用：Hadoop中服务器之间的鉴别

Server与Client之间基于共享秘密实现身份鉴别，也就是说c和s之间约定好一个秘密，c访问s时提供这个秘密来证明自己的身份，而Kerberos就负责建立这个秘密。这里的server指的不是Kerberos的服务器，而是提供服务的SS（Service Server）。

![Kerberos](pic/authen/Kerberos.png)

密钥分发中心KDC（Key Distribution Center）：

- Client和Server共同信任的第三方。
- KDC包括两种服务器：鉴别服务器AS（Authentication Server）和票据授予服务器TGS（Ticket Granting Server）。
- KDC维护一个包含所有账户的数据库account database，包括每个用户（Client）的用户名、口令、通过该用户口令计算出的用户主密钥（Client master key，即c-s共享密钥K）、与每个服务器共享的服务器主密钥（Server master key）

#### Kerberos协议描述

（1）客户端身份验证

- client向KDC的AS（Authentication Server）发送【用户id，请求服务的id】
- AS在数据库中检查用户id，发回两条消息
  - 消息A：用 c-s共享密钥K（也就是秘密） 加密的 客户端-TGS会话密钥
  - 消息B：使用TGS的私钥加密的 长期票据**TGT**（Ticket Granting Ticket），包含用户id， 客户端-TGS会话密钥，**TGT保证client是可信的合法用户**
- 客户端使用c-s共享密钥K解密消息A，获得客户端-TGS会话密钥

（2）客户服务授权

- client向TGS（Ticket Granting Server）发送【TGT，请求服务的id】
- TGS回复：使用客户端-TGS会话密钥 加密的 短期票据**ST/SGT**（Service ticket），包含用户id、c-s会话密钥

（3）用户用短期票据ST访问应用系统



PKINIT：解决长期使用问题



------

### 第十八章 OAuth和OIDC

单点登录SSO：一次鉴别，登录多个应用系统SP

伪SSO：中间的代理来进行口令管理，将用户的统一身份信息翻译成应用私有的用户账号，只对用户透明

真正的SSO：通过给用户发票来访问SP，对双方都透明。如Kerberos

开放授权OAuth：实现真正的SSO

CAS协议

![](pic/authen/oauth模型.png)

#### OAuth2.0

OAuth是一种授权协议

Client：希望获得资源的网站
User-Agent：用户的浏览器
Authorization Server：授权服务器，提供 用户访问资源 这一行为的access token
Resource Server：提供资源的服务器

一个背景：Alice要使用Facebook访问提供资源的Google上的照片

- client先请求用户的授权；用户给client发送授权许可
- client向资源的授权服务器出示授权许可，请求access token；授权服务器发给client一个access token
- client每次利用access token来获取资源

![](pic/authen/oauth.png)

CSRF攻击：攻击者诱骗已经登录aaa的用户点击，导致用户在aaa的账号与攻击者的weibo绑定

#### OIDC

OIDC（OpenID Connect）：基于OAuth2.0身份鉴别，使用TLS，OIDC 与 OAuth 2.0 相比，多了认证的能力。授权服务器不但能够返回用户的 access_token，让第三方通过 access_token 调用用户授权过的接口（用户授权），还可以返回用户的 id_token，第三方可以将 id_token 用作用户身份标识（用户认证）。

------

### 第十九章 基于可信环境的身份鉴别方案

移动终端的鉴别，尽量少使用口令

两段式鉴别：移动终端鉴别用户，如生物特征；网络服务鉴别移动终端

在线快速身份FIDO（Fast Identity Online）：基于非对称加密的可信设备鉴别，使用UAF协议

- 设备注册到远端服务器：人通过指纹启动设备鉴别，设备产生公私钥对，公钥和用户账户信息发给服务器
- 登录：服务器发送挑战，用户指纹解锁设备鉴别器authenticator，设备用私钥对 服务器挑战 签名发给服务器，服务器验证

aaid：设备型号id

------

### 第二十章 多种类型的身份鉴别

多因素的身份鉴别：服务器端两种独立鉴别方式，口令、生物特征

### 复习

判断题、简答题
